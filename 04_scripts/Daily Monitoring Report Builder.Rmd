---
title: "`Daily Monitoring Report`"
author: "BGD GIS DATA UNIT - Ben Smith"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
html_document:
code_folding: hide
---


```{r For_Testing, eval=TRUE, echo=FALSE}
# TODO - check that eval=TRUE
# https://stackoverflow.com/questions/64904061/kable-styling-inside-a-loop
# # --- Testing:

# Data Paths (CHANGE) -----------------------------------------------------

population <- c("host", "refugee")[2]

data_path <- audit_zip_dir <- paste0("../02 Data Collection and Planning/Quant/4_Data_collection/", population, "/Day7/")

# CAMP THURSDAY
# data_file_name  <- "Camp_JMSNA_2021_-_latest_version_-_False_-_2021-07-15-12-31-51.xlsx"
# audit_name      <- "a5C6hZmgWjP2NcTwt5GAb8_2021_07_15_12_33_07"

# HOST THURSDAY
# data_file_name  <- "Host_JMSNA_2021_-_latest_version_-_False_-_2021-07-15-13-04-42.xlsx"
# audit_name      <- "aqwujmBVgmCsd2wJW98WWW_2021_07_15_13_05_28"

# HOST SUNDAY:
# data_file_name  <- "Host_JMSNA_2021_-_latest_version_-_False_-_2021-07-18-12-56-21.xlsx"
# audit_name      <- "aqwujmBVgmCsd2wJW98WWW_2021_07_18_12_58_50"

# REFUGEE SUNDAY:
# data_file_name  <- "Camp_JMSNA_2021_-_latest_version_-_False_-_2021-07-18-12-32-51.xlsx"
# audit_name      <- "a5C6hZmgWjP2NcTwt5GAb8_2021_07_18_12_36_20"

# HSOT MONDAY
# data_file_name  <- "Host_JMSNA_2021_-_latest_version_-_False_-_2021-07-19-12-29-14.xlsx"
# audit_name      <- "aqwujmBVgmCsd2wJW98WWW_2021_07_19_12_30_43"

# CAMP MONDAY
# data_file_name  <- "Camp_JMSNA_2021_-_latest_version_-_False_-_2021-07-19-12-18-50.xlsx"
# audit_name      <- "a5C6hZmgWjP2NcTwt5GAb8_2021_07_19_12_20_30"

# HOST SUNDAY
# data_file_name  <- "Host_JMSNA_2021_-_latest_version_-_False_-_2021-07-25-13-31-12.xlsx"
# audit_name      <- "aqwujmBVgmCsd2wJW98WWW_2021_07_25_13_33_04"

# CAMP SUNDAY
data_file_name  <- "Camp_JMSNA_2021_-_latest_version_-_False_-_2021-07-25-13-17-33.xlsx"
audit_name      <- "a5C6hZmgWjP2NcTwt5GAb8_2021_07_25_17_52_51"


# Setup -------------------------------------------------------------------

library(rmarkdown)
day_to_run <- Sys.Date()-1
write_csv_output <-c("yes", "no")[1]
eval_audit = TRUE


# Sample Data (change if not working on Ben's PC) -------------------------

if(population=="refugee"){
  kobo_tool <- "../01 Design/3_Tools/Quant/Kobo/Camp_JMSNA_2021.xlsx"
  sample_sheet_path = "C:/Users/Ben SMITH/Documents/Bangladesh/REACH Projects/MSNA 2021/JMSNA_sample_for_verification_camps.xlsx"
}
if(population=="host"){
  kobo_tool <- "../01 Design/3_Tools/Quant/Kobo/Host_JMSNA_2021.xlsx"
  sample_sheet_path = "C:/Users/Ben SMITH/Documents/Bangladesh/REACH Projects/MSNA 2021/JMSNA_Host_Sample_for_verification.xlsx"
}


# Output paths (should not need to change) --------------------------------

hh_path <- paste0("02_inputs/", population, "/01_raw_data/hh.csv")
indv_path <- paste0("02_inputs/", population, "/01_raw_data/indv.csv")
indv_dis_repeat_path <- paste0("02_inputs/", population, "/01_raw_data/indv2.csv")

date_log_path <- paste0("05_outputs/01_daily_monitoring/", population, "/date_log/")
cleaning_log_path <- paste0("05_outputs/03_cleaning_log/", population, "/")

copy_zip_to <- paste0("05_outputs/01_daily_monitoring/", population, "/audit/", day_to_run, ".zip")
path_unzip <- "06_others/audit_temp"
if(eval_audit==TRUE){
audit_zipfile <- paste0(audit_zip_dir, audit_name, ".zip")
audit_node <- paste0("/", unlist(strsplit(audit_name, "_"))[1], "/")
}

```

```{r setup, include=FALSE}
# If you are editing this script and need to set the working directory of the chunks, use this: Else it will run from the project directory.
knitr::opts_knit$set(root.dir = "C:/Users/Ben SMITH/SynDrive/REACH_BGD/REACH/Ongoing/70XXX - J-MSNA 2021/04 Data Analysis")

knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning = FALSE)
```

```{r Libraries, echo=FALSE, include=FALSE, warning = FALSE, message=FALSE}

# Preamble for setting up the data collection:

# Set the default chuck settings:
# getwd()
# Load in libraries ... Surely these are more than we need?
library(tidyr) # used for pivot_longer
library(dplyr)
library(stringr)
library(lubridate) # (for ymd, remove dependence if possible)
library(kableExtra) # install.packages("kableExtra")
library(readxl)
library(openxlsx)
library(plotly) # For plotting the box plot of durations
library(rgdal) # For reading in the KML files for checking sample locations.
# library(knitr)

source("04_scripts/functions/Load_Audit.R")
source("04_scripts/functions/utils.R")
ID_cols = c("reported_date", "X_uuid", "enumerator_id", "enumerator_name", "team", "respondent_id", "instance_name")
if(population=="refugee"){ID_cols = c(ID_cols, "survey_type")}

```


```{r Loading_data, echo=FALSE}
# Load the survey data:
# getwd()
# load KoBo tool 
if(population == "host"){

  survey_sheet <- read_xlsx(kobo_tool, sheet = 1)
  choice_sheet <- read_xlsx(kobo_tool, sheet = 2)

  survey_sheet$name <- gsub(x =  survey_sheet$name, pattern = "-", replacement = ".")
  
  # >>> This will need to be changed when we move from pilot to data collection:
  sample_location = read_xlsx(path = sample_sheet_path, sheet = "Data_collection") 
  
  # Coerce the data into the form desired:
  colnames(sample_location)[1] = c("respondent_id")
  sample_location$Age = as.numeric(sample_location$Age)
  sample_location$Union = tolower(sample_location$Union)
  sample_location$Union = gsub(pattern = " ", replacement = "_", x = sample_location$Union)
  sample_location$Ward = tolower(sample_location$Ward)
  sample_location$Ward = gsub(pattern = " ", replacement = "_", x = sample_location$Ward)
    
} else {
  
  survey_sheet <- read_xlsx(kobo_tool, sheet = 1)
  choice_sheet <- read_xlsx(kobo_tool, sheet = 2)

  survey_sheet$name <- gsub(x =  survey_sheet$name, pattern = "-", replacement = ".")
  
  FCNs = read_xlsx(path = sample_sheet_path, sheet = "Refugee_data_collection")
  
  # Coerce the data into the form desired:
  colnames(FCNs) = c("respondent_id", "FCN", "Camp")
  FCNs$respondent_id = as.numeric(FCNs$respondent_id) ; FCNs$FCN = as.numeric(FCNs$FCN)
  FCNs$Camp = tolower(FCNs$Camp)
  FCNs$Camp = gsub(pattern = " ", replacement = "_", x = FCNs$Camp)
  FCNs$Camp = gsub(pattern = "_ext", replacement = "e", x = FCNs$Camp)
  FCNs$Camp = gsub(pattern = "nayapara_rc", replacement = "camp_nrc", x = FCNs$Camp)
  FCNs$Camp = gsub(pattern = "kutupalong_rc", replacement = "camp_krc", x = FCNs$Camp)
  
}

# Convert the data from xlsx to csv's:
  # This is because it is read into R better as csv's, but we do not want to do this conversion manually.
  # This will overwrite the previous csv's.
  # There is a function in the utils.R script that may also do this (can't remember which of us wrote it).
  
  # hh
  data_sheet = read_xlsx(paste0(data_path, data_file_name), sheet = 1); write.csv(x = data_sheet, file = hh_path, row.names = FALSE)
  # indv
  data_sheet = read_xlsx(paste0(data_path, data_file_name), sheet = 2); write.csv(x = data_sheet, file = indv_path, row.names = FALSE)
  # indv_disability_repeat
  data_sheet = read_xlsx(paste0(data_path, data_file_name), sheet = 3); write.csv(x = data_sheet, file = indv_dis_repeat_path, row.names = FALSE)

# load datav from csv's:
hh <- read.csv(hh_path, stringsAsFactors = FALSE, na.strings=c("", " ", NA))
indv <- read.csv(indv_path, stringsAsFactors = FALSE, na.strings=c("", " ", NA))
indv_dis_repeat <- read.csv(indv_dis_repeat_path, stringsAsFactors = FALSE, na.strings=c("", " ", NA))

# Change some of the column names in the individual datasets: 
  # 1. X_submission__uuid in indv
  names(indv) <- gsub(x =  names(indv), pattern = "X_submission__uuid", replacement = "X_uuid")
  names(indv) <- gsub(x =  names(indv), pattern = "_submission__uuid", replacement = "X_uuid") # Should be the above, but this covers whether the X is lost or not
  # 2. X_submission__uuid in indv_dis_repeat
  names(indv_dis_repeat) <- gsub(x = names(indv_dis_repeat), pattern = "X_submission__uuid", replacement = "X_uuid",)
  names(indv_dis_repeat) <- gsub(x = names(indv_dis_repeat), pattern = "_submission__uuid", replacement = "X_uuid",)
  # 3. ind_number_dis in indv_dis_repeat
  names(indv_dis_repeat) <- gsub(x = names(indv_dis_repeat), pattern = "ind_number_dis", replacement = "ind_number")

# Create a variable to contain the X_uuid and the enumerator id:
# hh_enumerator_id <- hh %>% select(X_uuid, enumerator_id)
  
# TODO - Remove if not used for testing:
# hh$survey_type = c("in_person", "remote")
# hh$respondent_id_inperson = rep(NA, nrow(hh))
# hh$respondent_id_inperson[hh$survey_type=="in_person"] = sample(x = 1:100, size = length(which(hh$survey_type=="in_person")), replace = TRUE)

```


```{r Date_log, echo=FALSE}
## Create Date Log

# This section records the dates that the surveys were initially checked by this script. There will be a separate date_log_full file in the Data Analysis outputs folder for both the host and refugee datasets. This uses the hh datasets. It is only writen if 'output' == yes in the "daily_checks.R" script. This will output a date_log_full.csv file that contains all of the dates for each community as well as archiving .csv's that record each instance the date logs are written.   


# >>> REQUIRED ONLY ON THE FIRST DAY OF DATA COLLECTION
# date_log_full <- data.frame("X_uuid" = hh[, "X_uuid"], "reported_date" = day_to_run)
# write.csv(date_log_full, paste0(date_log_path, "date_log_full.csv"), row.names=FALSE)
# <<<


# Read in the previous date log:
date_log <- read.csv(paste0(date_log_path, "date_log_full.csv"), 
                     stringsAsFactors = FALSE, na.strings = c("", " ", NA))

# Store the monitoring period:
prev_monitor = max(date_log$reported_date, na.rm = TRUE)

# Convert the excel csv date format to ymd:
# If this has been fiddled with in Excel then the format may not be correct and you will get an error. 
# TODO Make more robust
date_log$reported_date <- ymd(date_log$reported_date) 

# Join the dates of surveys that have already been monitored to the input data:
hh <- hh %>% dplyr::left_join(date_log, by = "X_uuid")
# Fill any blank reported dates (i.e. new data entries) with today's date
if(length(is.na(hh$reported_date))>0){hh$reported_date <- if_else(is.na(hh$reported_date), day_to_run, hh$reported_date)}

# Update the date_log_full with the new data and their monitoring dates:
date_log_full <- hh %>% select(X_uuid, reported_date)

if(write_csv_output == "yes"){
 write.csv(date_log_full, paste0(date_log_path, "Daily_Archive/date_log_", gsub(x = day_to_run, pattern = "-", replacement = "_"), ".csv"), row.names=FALSE)
 write.csv(date_log_full, paste0(date_log_path, "date_log_full.csv"), row.names=FALSE)
 
}

```


```{r Todays_data, echo=FALSE}
### Create daily datasets

# These datasets contain all of the data that has not yet been monitored.

# Household:
  # Create a dataset containing today's data with consent:
  hh_consent_full  <- hh %>% filter(informed_consent =="yes")
  hh_consent_daily <- hh %>% filter(informed_consent =="yes" & reported_date == day_to_run)
  
  # TODO: Delete?
  # Create a dataset that contains all of the hh data with consent:
  # hh_consent_daily <- hh %>% filter(informed_consent =="yes") # to run full data
  # hh_day_data <- hh %>% filter(reported_date == day_to_run) 

# Individual
  # # Create a vector of the UIDs in today's consented data:
  #  <- hh_consent_daily$X_uuid  #to run daily data
  
  # Create a dataset that contains all of the individual data with consent:
  indv_daily_data <- indv %>% filter(X_uuid %in% hh_consent_daily$X_uuid)

# Individual Disability Repeat loop:
  # indv_dis_repeat_daily_data <- indv_dis_repeat %>% filter(ind_number %in% indv_daily_data$ind_number)
  indv_dis_repeat_daily_data <- indv_dis_repeat %>% filter(X_uuid %in% hh_consent_daily$X_uuid)
```


## 1. Daily Progress Tracking
Community: **`r population`**

Data path: `r paste0(data_path, data_file_name)`

Total number of consenting household surveys taken so far for `r population` community is **`r length(which(hh$informed_consent=="yes"))`**.

Total number of consenting household surveys taken in the monitoring period is **`r length(which(hh_consent_daily$informed_consent=="yes"))`**.

The monitoring period is `r paste0(prev_monitor, " to ", Sys.time())`. Any surveys completed after, but on the same day, that the previous data was downloaded will be included here.

The following table shows the **number of surveys** since the start of data collection:
```{r Progress_tracking, eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

if(population=="host"){
  survey_complete_by_reach <- hh %>%  group_by(union_name, ward_name) # , reported_date
} else {
  survey_complete_by_reach <- hh %>%  group_by(camp_name) # , reported_date
}

# Create a dataset recording the number of surveys done so far per area and how many consented:
progress_tracking = function(survey){
  x = survey %>% summarise(
    "Total Surveys" = n(),
    "reached: yes" = sum(reached == "yes", na.rm = T),
    "reached: nobody_answering" = sum(reached == "nobody_answering", na.rm = T),
    "reached: inactive_sim" = sum(reached == "inactive_sim", na.rm = T),
    "consent: yes" = sum(informed_consent =="yes", na.rm = T),
    "consent: no" = sum(informed_consent =="no", na.rm = T),
    "consent: not_eligible" = sum(informed_consent =="not_eligible", na.rm = T),
    "consent: child_headed_hh" = sum(informed_consent =="child_headed_hh", na.rm = T)
    )
  return(x)
}

  if(population=="host"){
  survey_complete_by_reach <- progress_tracking(survey = survey_complete_by_reach)
  survey_complete_by_reach <- survey_complete_by_reach[order(survey_complete_by_reach$union_name,
                                                             survey_complete_by_reach$ward_name),]
  
  kable_styling(kable_input = kable(
    x = survey_complete_by_reach, longtable = T, booktabs = T, linesep = "", align = "c",
    row.names = FALSE, caption = "Total number of surveys per area (union)."), position = "center")
  
} else {
  # Remote:
  survey_complete_by_reach_rem <- progress_tracking(survey_complete_by_reach %>% filter(survey_type=="phone" | is.na(survey_type)))
  survey_complete_by_reach_rem <- survey_complete_by_reach_rem[order(
    as.numeric(substr(x = survey_complete_by_reach_rem$camp_name, start = 6,
                      nchar(survey_complete_by_reach_rem$camp_name)))),]
  # In Person:
  survey_complete_by_reach_imp <- progress_tracking(survey_complete_by_reach %>% filter(survey_type=="in_person"))
  survey_complete_by_reach_imp <- survey_complete_by_reach_imp[order(
    as.numeric(substr(x = survey_complete_by_reach_imp$camp_name, start = 6,
                      nchar(survey_complete_by_reach_imp$camp_name)))),]
  
  kable_styling(kable_input = kable(
    x = survey_complete_by_reach_imp, longtable = T, booktabs = T, linesep = "", align = "c",
    row.names = FALSE, caption = "Total number of in person surveys per camp."), position = "center")
    
}
  
if(population=="refugee"){ # Second if statement for this table as kable only prints 1 if 2 are included in single statement.
  kable_styling(kable_input = kable(
    x = survey_complete_by_reach_rem, longtable = T, booktabs = T, linesep = "", align = "c", 
    row.names = FALSE, caption = "Total number of remote surveys per camp."), position = "center")
}

```

---


## 2. Survey verification (Duplicate IDs) 

#### Check whether there are duplicated respondent IDs in the consenting data for this monitoring period:

Table for data collected remotely:
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# TODO Make this output ALL instances of duplicates, not just one instance of each.
# Currently this finds duplicates that are in all (including non consent), but only shows consenting daily data. 

# subset to the data we are interested in from ALL household data:  
if(population=="refugee"){
  
  # For camps, we only want remote data:
  IDs <- hh_consent_full$respondent_id[hh_consent_full$survey_type=="phone"]

  # For host, use all the data (as it was all remote:
} else {IDs <- hh_consent_full$respondent_id}


# Find duplicated IDs:
duplicate_id = IDs[which(duplicated(IDs))]

# Filter this to include only those in the monitoring period:
duplicate_id = duplicate_id[duplicate_id %in% hh_consent_daily$respondent_id]

# Create a dataset of the basic data for those surveys with duplicated IDs:
check_duplicate_respondent_id <- hh_consent_full %>% 
  filter(respondent_id %in% duplicate_id) %>%
  select(ID_cols) %>% 
  arrange(respondent_id)

kable_styling(kable_input = kable(x = check_duplicate_respondent_id,
                                  longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, 
                                  caption = "Surveys where respondent_id is not unique"),
              position = "center")

```

---

Table for data collected in person: [camps only]
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# Copied from above, so issues there will be present here.

# Filter the dataset to only use remotely collected data:
if(population=="refugee"){

  # subset to the data we are interested in:  
  IDs <- hh_consent_full$respondent_id_inperson[which(hh_consent_full$survey_type=="in_person")]
  # IDs <- hh_consent_full %>% filter(survey_type=="in_person") %>% select(respondent_id_inperson)

  # Find duplicated IDs in ALL household data:
  duplicate_id = IDs[which(duplicated(IDs))]
  
  # Filter this to include only those in the monitoring period:
  duplicate_id = duplicate_id[duplicate_id %in% hh_consent_daily$respondent_id_inperson]
  
  # Create a dataset of the basic data for those surveys with duplicated IDs:
  check_duplicate_respondent_id <- hh_consent_full %>% 
    filter(respondent_id_inperson %in% duplicate_id) %>%
    select(ID_cols, respondent_id_inperson) %>% 
    arrange(respondent_id_inperson)
  
  kable_styling(kable_input = kable(x = check_duplicate_respondent_id,
                                    longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, 
                                    caption = "Surveys where respondent_id is not unique"),
                position = "center")
}


```

---

#### Flag if sample FCN not identical with respondent FCN (if given) [camps only]

This only uses data collected remotely. 
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# TODO - check whether this manages cases where no FCN given
if(population=="refugee"){
  
  FCN_missmatch <- left_join(x = hh_consent_daily[, c(ID_cols, "hh_fcn", "camp_name")],
                            y = FCNs[, c("FCN", "respondent_id", "Camp")],
                             by = c("respondent_id"="respondent_id")) 
  
  #TODO - check that 'remote is the opposite of in_person.
  FCN_missmatch <- FCN_missmatch %>% filter(survey_type=="phone")
  
  FCN_missmatch$wrong_FCN <- FCN_missmatch$hh_fcn != FCN_missmatch$FCN
  FCN_missmatch$wrong_camp <- FCN_missmatch$camp_name != FCN_missmatch$Camp
  
  FCN_missmatch = FCN_missmatch[which(FCN_missmatch$wrong_FCN==TRUE | FCN_missmatch$wrong_camp==TRUE), ]
  
  FCN_missmatch = FCN_missmatch %>% select(ID_cols, wrong_FCN, "hh_fcn", "FCN", wrong_camp, "camp_name", Camp)
  
  kable_styling(kable_input = kable(x = FCN_missmatch, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                                  caption= "Sample Camp Name is not identical with respondent camp_name"),
              position = "center")
  }

```

---

#### Flag if sample union and ward do not match the sample data [host only]
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

if(population=="host"){
  
  admin_missmatch <- left_join(x = hh_consent_daily[,c(ID_cols, "union_name", "ward_name")],
                             y = sample_location,
                             by = c("respondent_id"="respondent_id"))
  
  admin_missmatch$Age <- admin_missmatch$Gender <- admin_missmatch$Source <- NULL # remove columns
  
  admin_missmatch <- admin_missmatch[which((admin_missmatch$union_name != admin_missmatch$Union) |
                                             (admin_missmatch$ward_name != admin_missmatch$Ward)), ]
  
  admin_missmatch <- admin_missmatch %>% relocate(ward_name, .after = "Union")
  
  # colnames(admin_missmatch) = c("X_uuid", "enumerator_id", "reported_date", "respondent_id", "union_name", "ward_name", "Union", "Ward")
  
  
  kable_styling(kable_input = kable(x = admin_missmatch, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                                  caption= "Survey union_name or ward_name does not match sample Union or Ward"),
              position = "center")
}

```

---

#### Flag if sample Age/gender is not identical to Head of Household age/gender [host only]
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

if(population=="host"){
  
  age_missmatch <- left_join(x = hh_consent_daily[,c(ID_cols, "respondent_age", "resp_gender")],
                             y = sample_location,
                             by = c("respondent_id"="respondent_id"))
  
  age_missmatch$Age = round(age_missmatch$Age, 0)
  age_missmatch$Gender = tolower(age_missmatch$Gender)
  
  age_missmatch$Ward  <- age_missmatch$Union  <- age_missmatch$Source <- NULL # remove columns
  
  age_missmatch <- age_missmatch[which((age_missmatch$respondent_age != age_missmatch$Age) |
                                       (age_missmatch$resp_gender != age_missmatch$Gender)), ]
  
  # colnames(age_missmatch) = c("X_uuid", "enumerator_id", "reported_date", "respondent_id", )
  
  # rearrange the columns to make them simpler to read:
  age_missmatch = age_missmatch %>% relocate(respondent_age, .after = "Gender")
  
    
  kable_styling(kable_input = kable(x = age_missmatch, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                                  caption= "Survey respondent_age or resp_gender does not match sample Union or Ward"),
              position = "center")
}

```

---

#### Check the distance of the GPS point from the sample point.

[Camps only]

```{r eval=FALSE, echo=FALSE, results='asis', warning=FALSE, message=FALSE}
# Do some preparation for the following code chunks:

if(population=="refugee"){
  
  # Note the path to the sample KMLs:
  sample_kml_path = "C:/Users/Ben SMITH/SynDrive/REACH_BGD/REACH/Ongoing/70XXX - J-MSNA 2021/03_GIS/Samples for in Person Data Collection (camps)"
  
  # ---
  
  # Create a dataframe contaning the camp names and the sample IDs:
  camp_names = c("Camp 1E", "Camp 1W", "Camp 2E", "Camp 2W", "Camp 3", "Camp 4","Camp 4 Extension", "Camp 5",
                 "Camp 6", "Camp 7","Camp 8E", "Camp 8W", "Camp 9", "Camp 10",
                 "Camp 11", "Camp 12", "Camp 13", "Camp 14", "Camp 15",
                 "Camp 16", "Camp 17", "Camp 18", "Camp 19", "Camp 20", "Camp 20 Extension",
                 "Camp 21", "Camp 22", "Camp 23", "Camp 24", "Camp 25", 
                 "Camp 26", "Camp 27", "Kutupalong RC", "Nayapara RC")
  
  sample_names <- c("c1e","c1w","c2e","c2w","c3","c4","c4x","c5","c6","c7","c8e","c8w","c9","c10",
                    "c11","c12","c13","c14","c15","c16","c17","c18","c19","c20","c20x",
                    "c21","c22","c23","c24","c25","c26","c27","krc","nrc")
  
  temp_mat = matrix(nrow = 100, ncol = length(camp_names), data = NA)
  colnames(temp_mat) = camp_names 
  
  for(c in 1:ncol(temp_mat)){
    temp_mat[,c] = paste(sample_names[c], 1:100, sep = "_") 
  }
  
  camp_names = as.data.frame(temp_mat)
  
    # The following code can be used to do this in a bit more of a 'codey' way, but I think the brute force approach above is more robust.
    # camp_names = dir(sample_kml_path, pattern = "_sample_points.kml")
    # camp_names = unique(substr(x = camp_names, start = 1, stop = nchar(camp_names)-18))
  
  # ---
  
  # Create a vector of all the sample names, just for ease later:
  all_sample_IDs <- do.call(paste0, expand.grid(paste0(sample_names, "_"), 1:100))
  
  # ---
  
  # Change all of the sample IDs entered by enumerators to lower case:
  hh_consent_daily$respondent_id_inperson = tolower(hh_consent_daily$respondent_id_inperson)

  # ---
  # Read in all of the KML files:
  
  # Get a list of the KML sample files:
  kml_names = dir(sample_kml_path, pattern = "sample_points.kml")
  
  # Get a list of the camps sampled in this period:
  daily_camp_names <- gsub(x = unique(hh_consent_daily$camp_name), pattern = "_", replacement = " ")
    # Change the names to sensible ones:
    daily_camp_names <- gsub(x = daily_camp_names, pattern = "camp 4e", replacement = "camp 4 extension")
    daily_camp_names <- gsub(x = daily_camp_names, pattern = "camp 20e", replacement = "camp 20 extension")
    daily_camp_names <- gsub(x = daily_camp_names, pattern = "camp ktp", replacement = "kutupalong rc")
    daily_camp_names <- gsub(x = daily_camp_names, pattern = "camp nya", replacement = "nayapara rc")
  
  # Read in the relevant kml files~
  KMLs = list()
  for(k in 1:length(daily_camp_names)){
    x = kml_names[grep(pattern = paste0(daily_camp_names[k], "_"), x = tolower(kml_names))]
    KMLs[k] = readOGR(dsn = file.path(sample_kml_path, x))
  }
  
  # Name the files appropriately:
  names(KMLs) = daily_camp_names
  
  # ---
  # Subset the data that were collected remotely:
  
  location_data = hh_consent_daily %>% 
    select(ID_cols, camp_name, respondent_id_inperson) %>% 
    filter(survey_type == "in_person")
  
  # For testing:
  # location_data$respondent_id_inperson = sample(all_sample_IDs, size = nrow(location_data))

}

```


Check whether there are any incorrect respondent_id_inperson. (These should be the sample point names)
```{r eval=FALSE, echo=FALSE, results='asis', warning=FALSE, message=FALSE}
if(population=="refugee"){
  kable_styling(kable(x = location_data %>% filter(!respondent_id_inperson %in% all_sample_IDs), 
                      longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                      caption = "Sample IDs that do not match the intended pattern."),
                position = "center")
}
```

---

#### Sample location check

Flag all surveys that are more than 50m from their intended sample point.
```{r eval=FALSE, echo=FALSE, results='asis', warning=FALSE, message=FALSE}
if(population=="refugee"){
  
  # Create a subset of the data that we are interested in checking, only using the valid Sample IDs:
  location_data = location_data %>% filter(respondent_id_inperson %in% all_sample_IDs)
  
  # Create a column for recording issues with distance:
  location_data$flag = rep(NA, nrow(location_data))
  
  # Run through each survey and measure its distance from the intended sample point:
  for(i in location_data$respondent_id_inperson)){
    
    # location_data
  }
  
  readOGR()
  # sample_locations = 
  

# _gps_reading_latitude	
# _gps_reading_longitude
# _gps_reading_precision
}

```


## 3. Enumerator and survey duration issues 

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, message=FALSE}
# Durations:
if(eval_audit==TRUE){
# The Load_Audit function relies on there only being the relevant audit files in the other/audit folder. Therefore empty that folder ready for use:
# unlink(x = path_unzip, recursive = TRUE) # Commented as this should have been done following the previous use of the audit function.

# Load in the audit data:
audit_yes <- Load_Audit(data = hh,
                        filter.column = "informed_consent",
                        path.to.zip = audit_zipfile,
                        path.to.unzip = path_unzip,
                        copy.zip = TRUE,
                        path.to.copy.zip = copy_zip_to,
                        delete.unzipped=TRUE)

data = hh; filter.column = "informed_consent"; path.to.zip = audit_zipfile; path.to.unzip = path_unzip; copy.zip = TRUE; path.to.copy.zip = copy_zip_to; delete.unzipped=TRUE
# getwd()
# unzip(path.to.zip, exdir = path.to.unzip)
# all_uuid_df <- data.frame(all_uuids = basename(dirname(list.files(path_unzip, recursive=TRUE))),
#                           all_paths = dirname(list.files(path_unzip, recursive=TRUE, full.names = TRUE)))

dfl<-list()
for (i in 1:length(audit_yes)){
  d <- audit_yes[[i]]

  d$node <- gsub("//[1]", "", d$node) # does this do anything?...
  
  # Start the time checking after the informed consent question:
  start_question <- d %>% filter(node == paste0(audit_node, "informed_consent") & !is.na(event)) %>% select(end)
  start_question <- min(start_question$end)
  
  # Find the end question, after which times will not be checked:
  end_question <- d %>% filter(node==paste0(audit_node, "end_note") & !is.na(node)) %>% select(end)
  end_question<-max(end_question$end)
  
  # Find the duration of the survey:
  duration_ms <- end_question-start_question
    # convert to seconds:
    # duration_secs <- duration_ms/1000
    duration_minutes<- round(duration_ms/(1000*60), 1)
    
    # Assign the duration to a dataframe:
    dfl[[i]] <- data.frame(uuid = names(audit_yes)[i], duration_minutes = duration_minutes)
}

# Join the survey duration to the survey details (id etc.):
duration_df2 <- do.call("rbind", dfl) # << (not sure what this is doing)
duration_df2 <- duration_df2 %>% rename(X_uuid = uuid)

# Remove any infinite values:
# duration_df2 <- duration_df2 %>% mutate(duration_minutes = if_else(condition = is.infinite(duration_minutes), true = NA_real_, false = duration_minutes))
duration_df2$duration_minutes[is.infinite(duration_df2$duration_minutes)] = NA

# Print stats on the survey times:
paste0("In this monitoring period, mean survey time is: ", round(mean(duration_df2$duration_minutes, na.rm = T),0), " minutes. ",
       "Median survey time is: ", round(median(duration_df2$duration_minutes, na.rm = T),0), " minutes.")

plot_ly(x = duration_df2$duration_minutes, type = "box", name = "Duration (all data)", height = 200, frame = TRUE, text = duration_df2$uuid)

}
```

---

#### a) Surveys completed in less than 45 minutes
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
if(eval_audit==TRUE){
  
# The survey start/end in the forms are very different to the audit because there is often long waits within the questions before the survey starts, not sure why.
survey_time <- left_join(x = duration_df2, y = hh_consent_full %>% select(ID_cols)) %>%
  select(ID_cols, duration_minutes)

# Calculate the survey times of the surveys in the monitoring period only:
survey_time_LT45 <- survey_time %>% filter(reported_date == day_to_run, duration_minutes <45) # Don't think we need to filter by reported_date.

survey_time_LT45 <- survey_time_LT45[order(survey_time_LT45$duration_minutes, decreasing = FALSE),]

kable_styling(kable(x = survey_time_LT45, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption= "surveys which are completed in less than 45 min"),
              position = "center")
}
```

---

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# **a.ii - Survey longer than 1hr**
# if(eval_audit==TRUE){
# # Calculate the survey times of the surveys in the monitoring period only:
# survey_time_GT60 <- survey_time %>% filter(reported_date == day_to_run, duration_minutes >60) %>% rename("X_uuid"="uuid")
# 
# survey_time_GT60 <- survey_time_GT60[order(survey_time_GT60$duration_minutes, decreasing = TRUE),]
# 
# kable_styling(kable(x = survey_time_GT60, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
#                     caption= "Surveys which are completed in over 60 minutes"),
#               position = "center")
# }
```

---

#### b) Duration statistics by enumerator
Average time per survey for whole data collection period.

[Here, some enumerators may be duplicated if they spell their names differently on different surveys.]
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
if(eval_audit==TRUE){

# List the mean and median survey durations for each enumerator: 
duration_df3 <- left_join(x = duration_df2,
                          y = hh_consent_full %>% select(reported_date, X_uuid, enumerator_id, team))

duration_df3 <- duration_df3 %>% group_by(enumerator_id) %>% 
  summarise(mean_duration =  round(mean(duration_minutes, na.rm = TRUE),0),
            median_duration =  round(median(duration_minutes, na.rm=TRUE),0))

# Add the desired columns:
duration_df3 <- right_join(x = unique(hh_consent_full %>% select(enumerator_id, team)), 
                          y = duration_df3, by = "enumerator_id")

duration_df3 <- duration_df3[order(duration_df3$mean_duration, decreasing = FALSE),]

kable_styling(kable_input = kable(x = duration_df3, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                       caption= "Duration Statistics of enumerators"),
              position = "center")
}
```

---

```{r eval=FALSE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# **c) Duration by group for monitoring period:**
# 
# if(eval_audit==TRUE){
# # Find the group names: 
# group_list = c()
# for(l in 1:length(audit_yes)){
#   group = strsplit(x = audit_yes[[l]]$node, split = "/")
# 
#   # Extract from list:
#   group = sapply(group, "[",4)
#   
#   # Record node names:
#   group_list = c(group_list, group)
# }
# 
# # Reduce list to only unique group names:
# nodes_unique = unique(group_list) ; nodes_unique = nodes_unique[!is.na(nodes_unique)]
# 
# # Set up a matrix to hold the time information:
# times = matrix(data = NA, nrow = length(names(audit_yes)), ncol = length(nodes_unique))
# rownames(times) = names(audit_yes) ; colnames(times) = nodes_unique
# 
# for(l in 1:length(audit_yes)){
#   for(n in colnames(times)){
#     au = audit_yes[[l]]
#     x  = grep(pattern = n, x = au$node)
#     if(length(x)==0){next} # Skip if group not answered
#     t1 = min(au$start[x], na.rm = TRUE)
#     t2 = max(au$end[x], na.rm = TRUE)
#     times[l,n] = round((t2-t1)/ (1000*60),1)
#   }
# }
# 
# time_stats = data.frame(
#   # "Group" = colnames(times),
#   "Mean time" = colMeans(times, na.rm = TRUE),
#   "Standard Deviation" = apply(times,2,sd, na.rm =TRUE))
# 
# kable_styling(kable_input = kable(x = round(time_stats,0), longtable = T, booktabs = T, linesep = "", align = "c", row.names = TRUE,
#                                   caption= "Time taken in minutes for each group of questions"),
#               position = "center")
# }

```

---

#### d)  Number of surveys completed per enumerator per day:
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# Count the number of surveys done by each enumerator
  # Overall:
  a = hh_consent_full  %>% group_by(enumerator_id) %>% summarise("Overall" = n())
  # In monitoring period
  b = (hh_consent_daily %>% group_by(enumerator_id) %>% summarise("Monitoring_period" = n()))
  
overall_complete_by_enumerator = left_join(a,b)
  
colnames(overall_complete_by_enumerator) = c("enumerator_id", "Overall", "Monitoring period")

# Print table
kable_styling(kable_input = kable(x = overall_complete_by_enumerator, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, 
                                  caption = "Number of surveys completed per enumerator per day:"),
              position = "center")
```

---

#### e)	Check if enumerators selected dont_know for more than 15 questions
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# Find all of the answers that include don't know in the tool answer sheet.
kobo_dont_know_choices  <- choice_sheet %>% filter(name == "dont_know")
  # Below was from ST, BS thinks that this finds all answers (e.g. "dont_know_where") and that it shouldn't. Ben's version above.
  # kobo_dont_know_choices  <- choice_sheet %>% filter(grepl(pattern = "dont_know", x = name))

# Find all of the select one question types: 
kobo_survey_select_one <- survey_sheet %>% filter(grepl(pattern = "select_one", x = type)) 

# Remove the "select_one" from the type names: 
kobo_survey_select_one$type <- gsub(x = kobo_survey_select_one$type, pattern = "select_one", replacement = "") %>% trimws()

# Subset the choice sheet to show only the questions/answers that are select_one and dont_know: 
all_select_one_dont_know <- kobo_survey_select_one %>% filter(type %in% kobo_dont_know_choices$list_name) 
all_select_one_dont_know <- all_select_one_dont_know$name

# Find the columns in the three dataset that qualify for the check:
hh_select_one_dont_know_cols <- all_select_one_dont_know[all_select_one_dont_know %in% names(hh)]
indv_select_one_dont_know_cols <- all_select_one_dont_know[all_select_one_dont_know %in% names(indv)]
indv_dis_repeat_select_one_dont_know_cols <- all_select_one_dont_know[all_select_one_dont_know %in% names(indv_dis_repeat)]

hh_dont_know_mltiple_cols_name <- hh %>% select(contains(".dont_know")) %>% names()
indv_dont_know_mltiple_cols_name <- indv %>% select(contains(".dont_know")) %>% names()
indv_dis_repeat_dont_know_mltiple_cols_name <- indv_dis_repeat %>% select(contains(".dont_know")) %>% names()

# Create a dataset with a column that shows whether there are >15 don't knows for the three datasets:
# More code than needed here, I don't think we need mutate.
hh_pattern_dont_know <- hh_consent_daily %>% mutate(
  "hh_dont_know_rowsum" = 
    rowSums(hh_consent_daily[hh_select_one_dont_know_cols] == "dont_know", na.rm = T) +
    rowSums(hh_consent_daily[hh_dont_know_mltiple_cols_name], na.rm = T)) %>%
  select(ID_cols, "hh_dont_know_rowsum")

indv_pattern_dont_know <- indv_daily_data %>% mutate(
  "dont_know_rowsum" = 
    rowSums(indv_daily_data[indv_select_one_dont_know_cols] == "dont_know", na.rm = T) +
    rowSums(indv_daily_data[indv_dont_know_mltiple_cols_name], na.rm = T)) %>%
  group_by(X_uuid) %>% 
  summarise(indv_dont_know_rowsum = sum(dont_know_rowsum, na.rm = T)) %>%
  select(X_uuid, indv_dont_know_rowsum)

indv_dis_repeat_pattern_dont_know <- indv_dis_repeat_daily_data %>% mutate(
  "dont_know_rowsum" = 
    rowSums(indv_dis_repeat_daily_data[indv_dis_repeat_select_one_dont_know_cols] == "dont_know",na.rm = T) +
    rowSums(indv_dis_repeat_daily_data[indv_dis_repeat_dont_know_mltiple_cols_name],na.rm = T))%>%
  group_by(X_uuid) %>% 
  summarise(indv_dis_repeat_dont_know_rowsum = sum(dont_know_rowsum,na.rm = T)) %>% 
  select(X_uuid, indv_dis_repeat_dont_know_rowsum)

indv_all_pattern_dont_know <- left_join(x = indv_pattern_dont_know, y = indv_dis_repeat_pattern_dont_know)

dont_know_pattern_all <- hh_pattern_dont_know %>% left_join(indv_all_pattern_dont_know) %>% 
  mutate(
    "number_of_dont_know" = hh_dont_know_rowsum + indv_dont_know_rowsum + indv_dis_repeat_dont_know_rowsum) %>%
  select(ID_cols, number_of_dont_know, everything())

dont_know_more_than_15 <- dont_know_pattern_all %>% filter(number_of_dont_know >15)
# colnames(dont_know_more_than_15) = c("X_uuid", "enumerator_id", "Total", "HH", "individual_info", "indv_disability_repeat")

kable_styling(kable(x = dont_know_more_than_15, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption= "Surveys where more than 15 dont_know answer selected"),
              position = "center")

# TODO - check that STs code works once there is more responses

```


## 4. Logical inconsistencies


```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# Each row of the data cleaning SOP has a different code chunk below.
# **Clinics:** flag if more than 3 selected – add column showing the selected options
# -------------------------------------------------------------------------

```

---

#### Individuals_difficulties:
Flag if more than 33% of HH members selected
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# Flag if more than 33% of HH members selected – add column indicating number of HH members selected, hh_size, 
# and the values for indv_difficulty_seeing,indv_difficulty_hearing, indv_difficulty_walking, 
# indv_difficulty_remembering, indv_difficulty_selfcare, indv_difficulty_communicating for each selected individual

# Find the relevant column names:
difficulty_colnames <- indv_dis_repeat_daily_data %>% select(contains("difficulty")) %>% colnames()

individuals_difficulties <- indv_dis_repeat_daily_data %>% mutate(
  difficulty_col_rowsum = 
    rowSums(indv_dis_repeat_daily_data[difficulty_colnames] == "lot_of_difficulty", na.rm =T) +
    rowSums(indv_dis_repeat_daily_data[difficulty_colnames] == "cannot_do", na.rm= T), #) %>% 
  difficulty_col_rowsum = difficulty_col_rowsum>0) %>%
  
  group_by(X_uuid) %>% 
  summarise(
    Indvs_with_Diffs = sum(difficulty_col_rowsum, na.rm = T),
    Seeing = sum(indv_difficulty_seeing == "lot_of_difficulty" | indv_difficulty_seeing == "cannot_do", na.rm = T),
    Hearing = sum(indv_difficulty_hearing == "lot_of_difficulty" | indv_difficulty_hearing == "cannot_do", na.rm = T),
    Walking = sum(indv_difficulty_walking == "lot_of_difficulty" | indv_difficulty_walking == "cannot_do", na.rm = T),
    Remembering = sum(indv_difficulty_remembering == "lot_of_difficulty" | indv_difficulty_remembering == "cannot_do", na.rm = T),
    Selfcare = sum(indv_difficulty_selfcare == "lot_of_difficulty" | indv_difficulty_selfcare == "cannot_do", na.rm = T),
    Communicating = sum(indv_difficulty_communicating== "lot_of_difficulty" | indv_difficulty_communicating == "cannot_do", na.rm = T))
  
individuals_difficulties = 
  left_join(x = individuals_difficulties,
            y = hh_consent_daily %>% 
              select(ID_cols, hh_size)) %>% 
  mutate(
    # "hh_size_fraction_raw" = hh_size/3,
    # "hh_size_fraction" = round(hh_size_fraction_raw, digits=0),
    "difficulty_issue" = case_when(Indvs_with_Diffs>(hh_size/3)~ "yes", T~ NA_character_)) %>% 
  filter(difficulty_issue=="yes") %>% 
  select(ID_cols, hh_size, Indvs_with_Diffs, 
         Seeing, Hearing, Walking, Remembering, Selfcare, Communicating)

kable_styling(kable(x = individuals_difficulties, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption= "Individuals_difficulties"),
              position = "center")
```

---

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# **shelter_issues_reason 1**

```

---

#### shelter_issues_reason
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

shelter_issues_reason_inconsistency <- hh_consent_daily %>% mutate(
  roof = case_when((shelter_issues_reason.damage_roof==1 & (leaks_during_rain!="yes" & lack_of_insulation!= "yes"))~"yes",T~ "no"),
  window = case_when((shelter_issues_reason.damage_windows==1 & (leaks_during_rain!="yes" & lack_of_insulation!= "yes"))~"yes", T~"no"),
  structure = case_when((shelter_issues_reason.structure_unstable==1 & collapse_living_there!= "yes")~"yes",T~ "no"),
  trap_heat = case_when((shelter_issues_reason.materials_trap_heat==1 & limited_ventilation != "yes")~"yes",T~ "no"),
  lack_insulation = case_when((shelter_issues_reason.materials_dont_insulate==1 & lack_of_insulation!= "yes")~"yes",T~ "no"))


if(population == "refugee"){
  
  shelter_issues_reason_inconsistency$collapse = case_when(
    (hh_consent_daily$collapse_living_there =="yes" | 
       hh_consent_daily$collapse_with_other_hh =="yes" | 
       hh_consent_daily$with_other_hh =="yes" | 
       hh_consent_daily$collapse_in_open =="yes")~"yes",T~ "no")
  
  shelter_issues_reason_inconsistency = shelter_issues_reason_inconsistency %>% 
    select(ID_cols, shelter_issues_reason, leaks_during_rain, 
         lack_of_insulation, collapse_living_there, roof, window, structure, trap_heat, lack_insulation, limited_ventilation, 
         collapse, collapse_with_other_hh, with_other_hh, collapse_in_open)
  
  } else {
    
    shelter_issues_reason_inconsistency$collapse = case_when(hh_consent_daily$collapse_living_there =="yes" ~"yes", TRUE~ "no")
    
    shelter_issues_reason_inconsistency = shelter_issues_reason_inconsistency %>% 
    select(ID_cols, shelter_issues_reason, leaks_during_rain, 
         lack_of_insulation, collapse_living_there, roof, window, structure, trap_heat, lack_insulation, limited_ventilation)
}


for(i in c("roof", "window", "structure", "trap_heat", "lack_insulation")){
  
  x = shelter_issues_reason_inconsistency[shelter_issues_reason_inconsistency[, i]== "yes",] %>% 
    select(ID_cols, 
           shelter_issues_reason, leaks_during_rain, lack_of_insulation, collapse_living_there, limited_ventilation)
  
  kable(x = x, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, caption = i) %>%
  kable_styling("striped") %>% 
  htmltools::HTML() %>% 
  print
  # cat("/n")
  
}

# Add the collapse indicators separately so that there is more space in the above tables, combine these if you have time.
if(population == "refugee"){collapse_cols = c("collapse_living_there", "collapse_with_other_hh", "with_other_hh", "collapse_in_open")
} else {collapse_cols = "collapse_living_there"}

x = shelter_issues_reason_inconsistency[shelter_issues_reason_inconsistency$collapse== "yes",] %>% 
    select(ID_cols, 
           shelter_issues_reason, leaks_during_rain, lack_of_insulation, limited_ventilation,
           collapse_cols)
kable_styling(kable(x = x, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, caption = "collapse"), "striped")

```

---

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# -------------------------------------------------------------------------
# Improvement: flag if more than 5 selected – add column showing all selected options

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
#                     caption = "..."),
#               position = "center")
```

---

#### Improvement_reason 1:
Flag if did_not_receive_any_shelter_support & sold_materials selected – add column showing selected options
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

improvement_reason_inconsistency <- hh_consent_daily %>% mutate(
  improvement_reason_inconsistency = 
    case_when(improvement_reason.did_not_receive_any_shelter_support==1 & improvement_reason.sold_materials==1 ~"yes", T~ NA_character_)) %>% 
  filter(improvement_reason_inconsistency=="yes") %>%
  select(ID_cols, improvement_reason, improvement_reason.did_not_receive_any_shelter_support, improvement_reason.sold_materials)

kable_styling(kable(x = improvement_reason_inconsistency, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption = "improvement_reason_inconsistency 1"),
              position = "center")
```

---

#### Improvement_reason 2:
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# a
# ----

# Find the people with disabilities:
  # It appears that those without disabilities are listed, but do not have a 'calc_name' 
disabled <- indv_dis_repeat_daily_data[!is.na(indv_dis_repeat_daily_data$calc_name),]

able_males_18_59 = indv_daily_data %>% mutate(
  able_males_18_59 = case_when((ind_gender == "male" & individual_age %in% 18:59)~ "yes", TRUE~NA_character_)) %>%
  filter(able_males_18_59=="yes") %>%
  select(X_uuid, able_males_18_59)
  
# Find able males 18-59 by removing the disabled ones:
able_males_18_59 = able_males_18_59[(!able_males_18_59$X_uuid %in% disabled$X_uuid),] 
# able_males = able_males_18_59 %>% select(!disabled$X_uuid %in% able_males_18_59$X_uuid) # has error if no content # or you could try this

# Join able males with hh data and filter this to show conflicts:
improvement_reason_inconsistency2 <- hh_consent_daily %>% left_join(able_males_18_59) %>% 
  filter(improvement_reason.no_able_bodied_person==1 & able_males_18_59== "yes") %>%
  select(ID_cols, improvement_reason.no_able_bodied_person, able_males_18_59) 
  # difficulty_colnames: You may have to summarise the difficulty_colnames before you can add.

kable_styling(kable(x = improvement_reason_inconsistency2, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption = "flag if no_able_bodied_person & at least one male person in the household aged 18-59"),
              position = "center")

# b
# ----
improvement_reason_inconsistency2b <- hh_consent_daily %>% mutate(
  "conflict" = case_when(improvement_reason.no_need_to_improve==1 & (leaks_during_rain!="no" | 
                                                                       limited_ventilation !="no" |
                                                                       dirt_debris !="no" |
                                                                       lack_of_insulation !="no" |
                                                                       collapse_living_there !="no")~ "yes", TRUE~"no")) %>%
  filter(conflict=="yes") %>%
  select(ID_cols, improvement_reason.no_need_to_improve, leaks_during_rain, 
         limited_ventilation, dirt_debris, lack_of_insulation, collapse_living_there)

# colnames(improvement_reason_inconsistency2b) = c("reported date", "X uuid", "enumerator id", "conflict", "leaks during rain", 
#                                                  "limited ventilation", "dirt debris", "lack of insulation", "collapse living there") 

kable_styling(kable(x = improvement_reason_inconsistency2b, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption = "Stated 'improvement_reason.no_need_to_improve' but has shelter problems:"),
              position = "center")

```

---

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# **Shelter_materials_source**
# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
#                     caption = "..."),
#               position = "center")
```

---

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# **Shelter_paid**

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
#                     caption = "..."),
#               position = "center")
```

---

#### Group_nfi

This shows instances where there are >8 answers not selected out of the following:
"blankets", "mattresses_mats", "kitchen_sets", "torches_lights", "solar_lamps", "batteries",  "clothing", "winter_clothing", "shoes", "fans", "mosquito_nets", "bedding_items".

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

nfi_cols <- c("blankets", "mattresses_mats", "kitchen_sets", "torches_lights", "solar_lamps", "batteries", 
              "clothing", "winter_clothing", "shoes", "fans", "mosquito_nets", "bedding_items")

group_nfi_inconsistency <- hh_consent_daily %>% mutate(
  nfi_insufficient = case_when(rowSums(hh_consent_daily[nfi_cols]!= "yes", na.rm = T) >10~"yes")) %>%
  filter(nfi_insufficient=="yes") %>% 
  select(ID_cols, hh_size, nfi_cols)

# colnames(group_nfi_inconsistency) <- c("reported_date", "X_uuid", "enumerator_id", "blankets", "mattresses mats", "kitchen sets", "torches lights",
#                                        "solar lamps", "batteries", "clothing", "winter clothing", "shoes", "fans", "mosquito nets", "bedding items")

kable_styling(kable(x = group_nfi_inconsistency, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption = "group_nfi_inconsistency"),
              position = "center")
```

---

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# **alternative_cooking_fuel**

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
#                     caption = "..."),
#               position = "center")

```

---

#### health_distance
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# TODO - this may need edits so that it uses all data, not daily.
# distance_stats = data.frame(mean = mean(hh_consent_daily$health_distance, na.rm = T),
#                             sd = sd(hh_consent_daily$health_distance, na.rm = T))
# 
# distance_stats$"mean-2SD" = distance_stats$mean - 2*distance_stats$sd
# distance_stats$"mean+2SD" = distance_stats$mean + 2*distance_stats$sd

health_distance_inconsistensy <- hh_consent_daily %>% mutate(
  mean = round(mean(health_distance,na.rm = T),0),
  sd = round(sd(health_distance, na.rm = T),0),
  "mean_minus_2SD" = mean - 2*sd,
  "mean_plus_2SD" = mean + 2*sd,
  conflict = case_when((health_distance>90 |
                         health_distance> mean_plus_2SD | 
                         health_distance< mean_minus_2SD) ~ "yes", T~ NA_character_)) %>% 
  filter(conflict=="yes") %>% 
  select(ID_cols, health_distance,
         mean, sd, mean_minus_2SD, mean_plus_2SD, health_transportation)

# colnames(health_distance_inconsistensy) = c("reported date", "X uuid", "enumerator id", "health distance", "health distance mean", 
#                                             "health distance sd", "min allowable health distance", "max allowable health distance",
#                                             "health distance inconsistensy", "health transportation")

kable_styling(kable(x = health_distance_inconsistensy, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption = "health_distance_inconsistensy"),
              position = "center")
```

---

#### health_barriers_not_accessed, health_barriers_accessed, health_barriers_no_need
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

health_service_inconsistency<- hh_consent_daily %>% mutate(
  no_facility = case_when(((health_barriers_accessed.no_functional_facility_nearby==1 |
                                              health_barriers_accessed.health_services_are_too_far_away==1|
                                              health_barriers_not_accessed.no_functional_facility_nearby==1| 
                                              health_barriers_not_accessed.health_services_are_too_far_away==1|
                                              health_barriers_no_need.no_functional_facility_nearby==1 | 
                                              health_barriers_no_need.health_services_are_too_far_away==1) &
                                            health_distance<30) ~ "yes", T~ NA_character_),
  cannot_afford = case_when(((health_barriers_accessed.cannot_afford==1| 
                                 health_barriers_not_accessed.cannot_afford==1 |
                                 health_barriers_no_need.cannot_afford==1) &
                                paid_healthcare=="yes") ~ "yes", T~ NA_character_)) %>% 
  select(ID_cols, health_barriers_accessed, health_barriers_not_accessed, 
         health_barriers_no_need, health_distance, health_transportation, paid_healthcare, no_facility, cannot_afford)

# Distance check:
to_far = health_service_inconsistency %>% filter(no_facility=="yes") %>%  
  select(ID_cols, health_barriers_accessed, 
         health_barriers_not_accessed, health_barriers_no_need, health_distance, health_transportation)

kable_styling(kable(x = to_far, 
                    longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption = "No Facility"), position = "center")
# Afford Check:
cant_aff = health_service_inconsistency %>% filter(cannot_afford=="yes") %>%  
  select(ID_cols, health_barriers_accessed, health_barriers_not_accessed, 
         health_barriers_no_need, paid_healthcare)
  
kable_styling(kable(x = cant_aff, 
                    longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, 
                    caption = "cannot_afford"), position = "center")
```

---

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# **group_enrolment & group_distance_learning [CAMPS ONLY]**

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
#                     caption = "..."),
#               position = "center")
```

---

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# **group_formal_enrolment, group_informal_enrolment & group_distance_learning [HOST ONLY]**

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
#                     caption = "..."),
#               position = "center")
```

---

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# **group_send_back [CAMPS ONLY]**

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
#                     caption = "..."),
#               position = "center")
```

---

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# **group_send_back [HOST ONLY]**

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
#                     caption = "..."),
#               position = "center")
```

---

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# **Set up some age range for the following check:**

if(population == "refugee"){
  
  young_girls = c("girl_3_count", "girl_4_5_count") ; older_girls = c("girl_15_18_count", "girl_19_24_count")
  young_boys = c("boy_3_count", "boy_4_5_count") ; older_boys = c("boy_15_18_count", "boy_19_24_count")
  
  distance_girl_cols = c("distance_learning_girls_3", "distance_learning_girls_4_5", "distance_learning_girls_6_14",	
                           "distance_learning_girls_15_18", "distance_learning_girls_19_24")
  distance_boy_cols = c("distance_learning_boys_3", "distance_learning_boys_4_5", "distance_learning_boys_6_14",
                          "distance_learning_boys_15_18",  "distance_learning_boys_19_24")

  send_back_girl_cols = c("send_back_girls_3", "send_back_girls_4_5", "send_back_girls_6_14",	
                           "send_back_girls_15_18", "send_back_girls_19_24")
  send_back_boy_cols = c("send_back_boys_3", "send_back_boys_4_5", "send_back_boys_6_14",
                          "send_back_boys_15_18",  "send_back_boys_19_24")
  
  age_range = c(3,24)
  
  } else {
    
    young_girls = "girl_4_5_count" ; older_girls = "girl_15_18_count"
    young_boys = "boy_4_5_count" ; older_boys = "boy_15_18_count"
    
    distance_girl_cols = c("distance_learning_girls_4_5", "distance_learning_girls_6_14", "distance_learning_girls_15_18")
    distance_boy_cols = c("distance_learning_boys_4_5", "distance_learning_boys_6_14", "distance_learning_boys_15_18")
    
    send_back_girl_cols = c("send_back_girls_4_5", "send_back_girls_6_14", "send_back_girls_15_18")
    send_back_boy_cols = c("send_back_boys_4_5", "send_back_boys_6_14", "send_back_boys_15_18")
    
    age_range = c(4,18)
  }

# Find cases where there are young people in the home:
age = colnames(hh_consent_daily)[grep(pattern = "ind_age", colnames(hh_consent_daily))]
age = hh_consent_daily[,age]
age[age<age_range[1] | age>age_range[2]] = 0; age[age>=age_range[1] & age<=age_range[2]] = 1

# Find instances where individuals are working:
indv_with_income = colnames(hh_consent_daily)[grep(pattern = "individuals_income.individual", colnames(hh_consent_daily))]
indv_with_income = hh_consent_daily[,indv_with_income]

# Find instances where children are working:
child_income = age*indv_with_income;
child_income = rowSums(child_income, na.rm = TRUE)

# [The child working code is repeated lower down.]
```

---

#### distance_learning_barriers (girls)
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

relevant_cols = list(
  "working_outside_home" = c("children_income"),
  "lack_content_older_children" = c("older_girl_count"),
  "lack_content_younger_children" = c("young_girl_count"),
  "lack_light" = c("solar_lamps"),
  "marriage_pregnancy" = c("girls_married"))

LI_dist_learning_barriers_girls <- hh_consent_daily %>% mutate(
  
  children_income = child_income,
  older_girl_count = rowSums(hh_consent_daily[older_girls]),
  young_girl_count = rowSums(hh_consent_daily[young_girls]),
  working_outside_home = case_when((distance_learning_barriers_girls.working_outside_home == 1 & children_income==0)~"yes", T~ "no"),
  lack_content_older_children = case_when((distance_learning_barriers_girls.lack_content_older_children==1 & older_girl_count==0)~"yes", T~ "no"),
  lack_content_younger_children = case_when((distance_learning_barriers_girls.lack_content_younger_children==1 & young_girl_count==0)~"yes", T~ "no"),
  lack_light = case_when((distance_learning_barriers_girls.lack_light==1 & (solar_lamps=="yes"))~"yes", T~ "no"),
  marriage_pregnancy = case_when((distance_learning_barriers_girls.marriage_pregnancy==1 & girls_married== "yes")~"yes", T~ "no")) %>% # (girls_married== "yes" | child_marriage!="yes")
  
  select(ID_cols, distance_learning_barriers_girls,
         working_outside_home, lack_content_older_children, lack_content_younger_children, lack_light, marriage_pregnancy, unique(unlist(relevant_cols)),
         distance_girl_cols)

for(i in names(relevant_cols)){
  
  kable(x = LI_dist_learning_barriers_girls[LI_dist_learning_barriers_girls[,i]=="yes",] %>% 
          select(ID_cols,
                 distance_learning_barriers_girls, relevant_cols[[i]], distance_girl_cols),
        longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, caption = i) %>%
    kable_styling("striped") %>% 
    htmltools::HTML() %>% 
    print
  
}


```

---

#### distance_learning_barriers (boys)
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

relevant_cols = list(
  "working_outside_home" = c("children_income"),
  "lack_content_older_children" = c("older_boy_count"),
  "lack_content_younger_children" = c("young_boy_count"),
  "lack_light" = c("solar_lamps"),
  "marriage_pregnancy" = c("boys_married"))

LI_dist_learning_barriers_boys <- hh_consent_daily %>% mutate(
    
  children_income = child_income,
  older_boy_count = rowSums(hh_consent_daily[older_boys]),
  young_boy_count = rowSums(hh_consent_daily[young_boys]),
  working_outside_home = case_when((distance_learning_barriers_boys.working_outside_home == 1 & children_income==0)~"yes", T~ "no"),
  lack_content_older_children = case_when((distance_learning_barriers_boys.lack_content_older_children==1 & older_boy_count==0)~"yes", T~ "no"),
  lack_content_younger_children = case_when((distance_learning_barriers_boys.lack_content_younger_children==1 & young_boy_count==0)~"yes", T~ "no"),
  lack_light = case_when((distance_learning_barriers_boys.lack_light==1 & (solar_lamps=="yes"))~"yes", T~ "no"),
  marriage_pregnancy = case_when((distance_learning_barriers_boys.marriage_pregnancy==1 & boys_married== "yes")~"yes", T~ "no")) %>%
  
  
  select(ID_cols, distance_learning_barriers_boys,
         working_outside_home, lack_content_older_children, lack_content_younger_children, lack_light, marriage_pregnancy, unique(unlist(relevant_cols)),
         distance_boy_cols)

for(i in names(relevant_cols)){
  
  kable(x = LI_dist_learning_barriers_boys[LI_dist_learning_barriers_boys[,i]=="yes",] %>% 
          select(ID_cols, distance_learning_barriers_boys,
                 relevant_cols[[i]], distance_boy_cols),
        longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, caption = i) %>%
    kable_styling("striped") %>% 
    htmltools::HTML() %>% 
    print
  
}

```

---

#### send_back_barriers_girls
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

relevant_cols = list(
  "working_outside_home" = c("children_income"),
  "lack_content_older_children" = c("older_girl_count"),
  "lack_content_younger_children" = c("young_girl_count"),
  "marriage_pregnancy" = c("girls_married"))

send_back_barriers_girls <- hh_consent_daily %>% mutate(
  
  children_income = child_income,
  older_girl_count = rowSums(hh_consent_daily[older_girls]),
  young_girl_count = rowSums(hh_consent_daily[young_girls]),
  working_outside_home =           case_when((send_back_barriers_girls.working_outside_home == 1 & children_income==0)~"yes", T~ "no"),
  lack_content_older_children =    case_when((send_back_barriers_girls.lack_content_older_children==1 & older_girl_count==0)~"yes", T~ "no"),
  lack_content_younger_children =  case_when((send_back_barriers_girls.lack_content_younger_children==1 & young_girl_count==0)~"yes", T~ "no"),
  marriage_pregnancy =             case_when((send_back_barriers_girls.marriage_pregnancy==1 & girls_married== "yes")~"yes", T~ "no")) %>%
                                    
  select(ID_cols, send_back_barriers_girls,
         working_outside_home, lack_content_older_children, lack_content_younger_children, marriage_pregnancy, unique(unlist(relevant_cols)), send_back_girl_cols)

for(i in names(relevant_cols)){
  
  kable(x = send_back_barriers_girls[send_back_barriers_girls[,i]=="yes",] %>% 
            select(ID_cols, send_back_barriers_girls,
                   relevant_cols[[i]], send_back_girl_cols),
        longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, caption = i) %>%
    kable_styling("striped") %>% 
    htmltools::HTML() %>% 
    print
  
}

```

---

#### send_back_barriers_boys
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

relevant_cols = list(
  "working_outside_home" = c("children_income"),
  "lack_content_older_children" = c("older_boy_count"),
  "lack_content_younger_children" = c("young_boy_count"),
  "marriage_pregnancy" = c("boys_married"))

LI_send_back_barriers_boys <- hh_consent_daily %>% mutate(
  
  children_income = child_income,
  older_boy_count = rowSums(hh_consent_daily[older_boys]),
  young_boy_count = rowSums(hh_consent_daily[young_boys]),
  working_outside_home = case_when((send_back_barriers_boys.working_outside_home == 1 & children_income==0)~"yes", T~ "no"),
  lack_content_older_children = case_when((send_back_barriers_boys.lack_content_older_children==1 & older_boy_count==0)~"yes", T~ "no"),
  lack_content_younger_children = case_when((send_back_barriers_boys.lack_content_younger_children==1 & young_boy_count==0)~"yes", T~ "no"),
  marriage_pregnancy = case_when((send_back_barriers_boys.marriage_pregnancy==1 & boys_married== "yes")~"yes", T~ "no")) %>%
  
  select(ID_cols, send_back_barriers_boys,
         working_outside_home, lack_content_older_children, lack_content_younger_children, marriage_pregnancy, unique(unlist(relevant_cols)), send_back_boy_cols)

for(i in names(relevant_cols)){
  
  kable(x = LI_send_back_barriers_boys[LI_send_back_barriers_boys[,i]=="yes",] %>% 
          select(ID_cols, send_back_barriers_boys, 
                 relevant_cols[[i]], send_back_boy_cols),
        longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, caption = i) %>%
    kable_styling("striped") %>% 
    htmltools::HTML() %>% 
    print
  
}

```

---

#### send_back_challenges_girls
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

relevant_cols = list(
  "working_outside_home" = c("children_income"),
  "lack_content_older_children" = c("older_girl_count"),
  "lack_content_younger_children" = c("young_girl_count"),
  "marriage_pregnancy" = c("girls_married"))

send_back_challenges_girls <- hh_consent_daily %>% mutate(

  children_income = child_income,
  older_girl_count = rowSums(hh_consent_daily[older_girls]),
  young_girl_count = rowSums(hh_consent_daily[young_girls]),
  working_outside_home  = case_when((send_back_challenges_girls.working_outside_home == 1 & children_income==0)~"yes", T~ "no"),
  lack_content_older_children  = case_when((send_back_challenges_girls.lack_content_older_children==1 & older_girl_count==0)~"yes", T~ "no"),
  lack_content_younger_children = case_when((send_back_challenges_girls.lack_content_younger_children==1 & young_girl_count==0)~"yes", T~ "no"),
  marriage_pregnancy = case_when((send_back_challenges_girls.marriage_pregnancy==1 & girls_married== "yes")~"yes", T~ "no")) %>%
  
  select(ID_cols, send_back_challenges_girls,
         working_outside_home, lack_content_older_children, lack_content_younger_children, marriage_pregnancy, unique(unlist(relevant_cols)), send_back_girl_cols)

for(i in names(relevant_cols)){
  
  kable(x = send_back_challenges_girls[send_back_challenges_girls[,i]=="yes",] %>% 
            select(ID_cols, send_back_challenges_girls, 
                   relevant_cols[[i]], send_back_girl_cols),
        longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, caption = i) %>%
    kable_styling("striped") %>% 
    htmltools::HTML() %>% 
    print
  
}

```

---

#### send_back_challenges_boys
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

relevant_cols = list(
  "working_outside_home" = c("children_income"),
  "lack_content_older_children" = c("older_boy_count"),
  "lack_content_younger_children" = c("young_boy_count"),
  "marriage_pregnancy" = c("boys_married"))

send_back_challenges_boys <- hh_consent_daily %>% mutate(
  
  children_income = child_income,
  older_boy_count = rowSums(hh_consent_daily[older_boys]),
  young_boy_count = rowSums(hh_consent_daily[young_boys]),
  working_outside_home = case_when((send_back_challenges_boys.working_outside_home == 1 & children_income==0)~"yes", T~ "no"),
  lack_content_older_children = case_when((send_back_challenges_boys.lack_content_older_children==1 & older_boy_count==0)~"yes", T~ "no"),
  lack_content_younger_children = case_when((send_back_challenges_boys.lack_content_younger_children==1 & young_boy_count==0)~"yes", T~ "no"),
  marriage_pregnancy = case_when((send_back_challenges_boys.marriage_pregnancy==1 & boys_married== "yes")~"yes", T~ "no")) %>%
  
  select(ID_cols, send_back_challenges_boys,
         working_outside_home, lack_content_older_children, lack_content_younger_children, marriage_pregnancy, unique(unlist(relevant_cols)), send_back_boy_cols)


for(i in names(relevant_cols)){
  
  kable(x = send_back_challenges_boys[send_back_challenges_boys[,i]=="yes",] %>% 
          select(ID_cols, send_back_challenges_boys, 
                 relevant_cols[[i]], send_back_boy_cols),
        longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, caption = i) %>%
    kable_styling("striped") %>% 
    htmltools::HTML() %>% 
    print
  
}

```

---


#### never_enrolled when all children are enrolled

This has a lot of columns so that it is clear what is going on. We can reduce once confirmed it is as desired.

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

gender = c("boy", "girl")

for(i in gender){

  # 1. Find which households selected never enrolled for distance and sent back barriers:
  not_enroled_cols = c(paste0("distance_learning_barriers_", i, "s.never_enrolled"), 
                       paste0("send_back_barriers_", i, "s.never_enrolled"))
  not_enroled = rowSums(hh_consent_daily[not_enroled_cols], na.rm = TRUE) >0
  
  # 2. Count the number of boys in the household:
  child_count_col = colnames(hh_consent_daily)[grep(paste0("^", i, "_.*count$"), colnames(hh_consent_daily))] # "^boy_.*_count$" # ^=start, . = something, .*=something several times
  child_count = rowSums(x = hh_consent_daily[child_count_col], na.rm = TRUE)
  
  # 3. Count the number of boys enrolled in distance learning or who have been sent back:
  child_enrolled_col = colnames(hh_consent_daily)[grep(paste0("enrolment_", i, "s"), colnames(hh_consent_daily))]
  child_enrolled_col = child_enrolled_col[-grep("_dk", child_enrolled_col)]
  child_enrolled = rowSums(x = hh_consent_daily[child_enrolled_col], na.rm = TRUE)
    # Remove instances where children do not exist...
    child_enrolled[child_count==0]=NA
    
  # 4. Flag instances where 1.==TRUE & 2.==3. :
  flags = not_enroled & (child_enrolled==child_count)==TRUE
  
  # 5. Print a table 
  if(length(which(flags==TRUE))>0){
    
    flag_data = hh_consent_daily[, c(ID_cols, not_enroled_cols, child_count_col, child_enrolled_col)]
    flag_data = cbind(flag_data, child_count, child_enrolled)
  
    kable(x = flag_data[flags,],
        longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, 
        caption = paste0(i, "s never_enrolled == TRUE & all ",  i, "s enrolled.")) %>%
    kable_styling("striped") %>%
    htmltools::HTML() %>%
    print
    
  } else {print(paste0("No flags for ", i, "s."))}

}

```

#---

#### nutrition_barriers_not_accessed
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# Set columns of interest:
nutrition_barriers_not_accessed_cols <- c("nutrition_barriers_not_accessed.not_admitted", "nutrition_barriers_not_accessed.waiting_times",
                                          "nutrition_barriers_not_accessed.language_barriers")

# Select the instances where flags are triggered:
nutrition_barriers_not_accessed_inconsistency <- hh_consent_daily %>% mutate(
  
  child_taken_no_support = case_when(child_taken_no_support_HH_count>0 &
                                       rowSums(hh_consent_daily[nutrition_barriers_not_accessed_cols]==0, na.rm = T)~"yes", T~NA_character_),
  child_not_taken_after_referral = case_when((child_not_taken_after_referral_HH_count>0 & 
                                                nutrition_barriers_not_accessed.already_referred !=1) ~"yes", T~NA_character_)) %>% 
  
  select(ID_cols,
         child_not_taken_after_referral_HH_count,child_taken_no_support_HH_count,
         child_taken_no_support, child_not_taken_after_referral, nutrition_barriers_not_accessed, nutrition_barriers_not_accessed_cols)


# --- Add repeat_instance names to nutrition_barriers_not_accessed_inconsistency, as the HH data is calculated from the individual loop:

# Add a column to receive the repeat instance IDs: 
nutrition_barriers_not_accessed_inconsistency$repeat_instance_no_support = rep(NA, nrow(nutrition_barriers_not_accessed_inconsistency))
nutrition_barriers_not_accessed_inconsistency$repeat_instance_not_taken = rep(NA, nrow(nutrition_barriers_not_accessed_inconsistency))

# Find the UUIDs
uuIDs_of_interest = list(
  no_support_uuids = nutrition_barriers_not_accessed_inconsistency$X_uuid[which(nutrition_barriers_not_accessed_inconsistency$child_taken_no_support =="yes")],
  not_taken_uuids  = nutrition_barriers_not_accessed_inconsistency$X_uuid[which(nutrition_barriers_not_accessed_inconsistency$child_not_taken_after_referral =="yes")]
)

# For each of the two columns:
for(i in 1:length(uuIDs_of_interest)){
  
  # Check 
  if(i==1){child_col = "child_taken_no_support"} else{child_col = "child_not_taken_after_referral"}
  if(i==1){repeat_col = "repeat_instance_no_support"} else{repeat_col = "repeat_instance_not_taken"}
  
  Uuid_list = uuIDs_of_interest[[i]]
  
  # If there are uuid's to check:
  if(length(Uuid_list)>0){
    
    # Run through the UUIDs:
    for(j in Uuid_list){
    
    # find which individual responses match the UUID:
    temp = indv_daily_data[(indv_daily_data$X_uuid %in% j) & (indv_daily_data[child_col]==1),]
    
    # paste all of the repeat instances together:
    temp = paste(temp$repeat_instance_name, collapse = ", ")
    
    # Find where to add this data into the nutrition_barriers_not_accessed_inconsistency dataframe:
    nutrition_barriers_not_accessed_inconsistency[which(nutrition_barriers_not_accessed_inconsistency$X_uuid==j), repeat_col] = temp
    }
  }
}


# ---

# Print the tables:
kable_styling(kable(x = nutrition_barriers_not_accessed_inconsistency %>% 
                      filter(child_taken_no_support =="yes") %>%
                      select(ID_cols, repeat_instance_no_support,
                             # child_taken_no_support, child_not_taken_after_referral,
                             # nutrition_barriers_not_accessed_cols, nutrition_barriers_not_accessed.already_referred,
                             child_taken_no_support_HH_count, child_not_taken_after_referral_HH_count, nutrition_barriers_not_accessed),
                    longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption = "nutrition_barriers_not_accessed_inconsistency: child_taken_no_support. child_taken_no_support_HH_count>0 & != (not_admitted OR waiting_times OR language_barriers)"),
              position = "center")

kable_styling(kable(x = nutrition_barriers_not_accessed_inconsistency %>% 
                      filter(child_not_taken_after_referral == "yes") %>%
                      select(ID_cols, repeat_instance_not_taken,
                             # child_taken_no_support, child_not_taken_after_referral,
                             # nutrition_barriers_not_accessed_cols, nutrition_barriers_not_accessed.already_referred,
                             child_taken_no_support_HH_count, child_not_taken_after_referral_HH_count, nutrition_barriers_not_accessed),
                    longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption = "nutrition_barriers_not_accessed_inconsistency: child_not_taken_after_referral. child_not_taken_after_referral_HH_count>0 & != not already_referred"),
              position = "center")

```

---

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# **Nutrition 2**

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
#                     caption = "..."),
#               position = "center")
```

---

#### PLW admitted:
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
if(population=="refugee"){

  # case_when(hh_consent_daily$plw_admitted > hh_consent_daily$plw_sfs ~ "yes", TRUE~NA_character_)
  index = which(hh_consent_daily$plw_admitted > hh_consent_daily$plw_sfs)
  
  plw = hh_consent_daily[index, c(ID_cols, "plw_admitted", "plw_sfs")]
    
  kable_styling(kable(x = plw, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                      caption = "flag if plw_admitted > plw_sfs "), position = "center")
}

```

---

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# **Folic Acid**

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
#                     caption = "..."),
#               position = "center")
```

---

#### Food Barriers [Camps only]
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
if(population=="refugee"){
  
  food_barriers <- hh_consent_daily %>% mutate(
    Flag = case_when(((food_barriers.no_assistance == 1) |
                                 (food_barriers.feedback==1 & 
                                    feedback.did_not_know_where!=1 & 
                                    feedback.could_not_go_out!=1) |
                                 (food_barriers.lack_response==1 & 
                                    feedback.did_but_it_was_not_responded != 1 & 
                                    feedback.did_but_the_response_was_not_satisfactory != 1))~"yes", T~NA_character_)) %>%
      filter(food_barriers=="yes") %>% 
      select(ID_cols, food_barriers, feedback, food_barriers.no_assistance)
  
kable_styling(kable(x = food_barriers, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption = "food_barriers"),
              position = "center")
}
```

---

#### group_livelihood_coping
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# Set income columns of interest for 2nd check: [this is no longer desired].
# main_income = c("main_income_source.salaried_work", "main_income_source.casual_labor",
#                 "main_income_source.business", "main_income_source.cash_for_work",
#                 "main_income_source.donations")
# if(population=="host"){main_income = c(main_income, "main_income_source.government_benefits")}


# Find individual ages:
age = colnames(hh_consent_daily)[grep(pattern = "ind_age", colnames(hh_consent_daily))]
age = hh_consent_daily[,age]

# Convert to T/F based on whether their ages are in the desired ranges:
adult = age; adult[adult<=18] = 0; adult[adult>18] = 1; adult[is.na(adult)] = 0 # t(case_when(age>=18~TRUE, age<18~FALSE))
child = age; child[child<=18] = 1; child[child>18] = 0; child[is.na(child)] = 0 # t(case_when(age>=18~FALSE, age<18~TRUE))
marriage_age_child = age; marriage_age_child[marriage_age_child<=18] = 1; marriage_age_child[marriage_age_child>18] = 0; marriage_age_child[is.na(marriage_age_child)] = 0 # t(case_when(age>=18~FALSE, age<18~TRUE))

# Find whether individuals work as TRUE/FALSE:
indv_with_income = colnames(hh_consent_daily)[grep(pattern = "individuals_income.individual", colnames(hh_consent_daily))]
indv_with_income = hh_consent_daily[,indv_with_income]
indv_with_income[is.na(indv_with_income)]=0
# indv_with_income = rowSums(indv_with_income)
# indv_with_income = case_when(indv_with_income==1~TRUE, indv_with_income==0~FALSE) == if_else(condition = indv_with_income==1, true = 1, false = 0, missing = 0)
# rownames(indv_with_income) = hh_consent_daily$X_uuid

# Find which individuals can work but are over 18 then summerise this to a single vector:
child_income = child * indv_with_income ; child_income = rowSums(child_income, na.rm = TRUE)# ; child_income = > 0
adult_income = adult * indv_with_income ; adult_income = rowSums(adult_income, na.rm = TRUE)

# imcome_age = data.frame("X_uuid" = rownames(imcome_age), "imcome_age" = rowSums(imcome_age, na.rm = TRUE), row.names = NULL)
# TODO - I think that this should work, but you should check it once you have more data.

relevant_cols = list(
  "selling_food_rations" = c("main_income_source.sale_assistance", "selling_food_rations", "selling_nfis"), 
  "child_working_long_hours" = c("child_working_long_hours", "children_income"), 
  "child_marriage" = c("child_marriage", "girls_married", "boys_married", "children_not_staying_with_hh", "reason_not_with_hh", "girls_age10_count", "boys_age10_count"), 
  "risk_jobs" = c("risk_jobs", "indv_with_income"), 
  "adults_working_long_hours" = c("adults_working_long_hours", "adult_income")
)

# Do the checks:
group_livelihood_coping_inconsistency <- hh_consent_daily %>% mutate(
  
  indv_with_income = indv_with_income, children_income = child_income, adult_income = adult_income,
  selling_food_rations = case_when(((selling_food_rations == "yes" | selling_nfis == "yes") & main_income_source.sale_assistance != 1)~"yes", TRUE~"no"),
  child_working_long_hours = case_when((child_working_long_hours == "yes" & children_income ==0)~"yes", TRUE~"no"),
  child_marriage = case_when((child_marriage == "yes" & 
                                (girls_married == 0 | girls_age10_count == 0) & 
                                (boys_married == 0 | boys_age10_count == 0) &
                                (children_not_staying_with_hh != "yes" | 
                                   (children_not_staying_with_hh == "yes" & reason_not_with_hh.marriage != "marriage")))~"yes", TRUE~"no"),
  risk_jobs = case_when((risk_jobs == "yes" & rowSums(indv_with_income, na.rm = TRUE)==0)~"yes", TRUE~"no"),
  adults_working_long_hours = case_when((adults_working_long_hours == "yes" & adult_income == 0)~"yes", TRUE~"no")) %>%
  
  select(c(ID_cols,
           main_income_source, unique(unlist(relevant_cols))))

for(i in names(relevant_cols)){

  kable(x = group_livelihood_coping_inconsistency[group_livelihood_coping_inconsistency[,i]=="yes",] %>%
          select(ID_cols,
                 relevant_cols[[i]]),
        longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, caption = i) %>%
    kable_styling("striped") %>%
    htmltools::HTML() %>%
    print

}

```

---

#### group_livelihood_coping2
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# •	begging == “exhausted” | “not_available”
kable_styling(kable(x = hh_consent_daily[c(hh_consent_daily$begging=="exhaused" | hh_consent_daily$begging=="not_available"), 
                     c(ID_cols, "begging")],
    longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
    caption = "Flag if begging == “exhausted” | “not_available”"),
    "striped")


# •	selling_labor, child_working_long_hours, adults_working_long_hours, risk_jobs, hh_migration == “exhausted” 
kable_styling(kable(x = hh_consent_daily[
  c(hh_consent_daily$selling_labor=="exhaused" |
      hh_consent_daily$child_working_long_hours=="exhaused" |
      hh_consent_daily$adults_working_long_hours=="exhaused" |
      hh_consent_daily$risk_jobs=="exhaused" |
      hh_consent_daily$hh_migration=="exhaused"),
  c(ID_cols,
    "selling_labor", "child_working_long_hours", "adults_working_long_hours", "risk_jobs", "hh_migration")],
  longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
  caption = "Flag if selling_labor, child_working_long_hours, adults_working_long_hours, risk_jobs, hh_migration == “exhausted” "),
  "striped")

# # •	selling_labor, child_working_long_hours, adults_working_long_hours, risk_jobs, hh_migration == “exhausted” 
# kable_styling(kable(x = hh_consent_daily[
#   c(hh_consent_daily$selling_labor=="exhaused" |
#       hh_consent_daily$child_working_long_hours=="exhaused" |
#       hh_consent_daily$adults_working_long_hours=="exhaused" |
#       hh_consent_daily$risk_jobs=="exhaused" |
#       hh_consent_daily$hh_migration=="exhaused"),
#   c(ID_cols,
#     "selling_labor", "child_working_long_hours", "adults_working_long_hours", "risk_jobs", "hh_migration")],
#   longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
#   caption = "Flag if selling_labor, child_working_long_hours, adults_working_long_hours, risk_jobs, hh_migration == “exhausted” "),
#   "striped")


# For all strategies “not_available” is selected:
  # Find the strategies:
  # coping_strategies = c("selling_labor", "child_working_long_hours", "adults_working_long_hours", "risk_jobs", "hh_migration")
  coping_strategies = survey_sheet$name[which(survey_sheet$type == "select_one livelihood_coping")]
  coping_strategies = hh_consent_daily[c(ID_cols, coping_strategies)]
  
  
  # Find which rows have dont_knows:
  coping_strategies$flag = apply(coping_strategies, 1, function(x) length(which(x=="not_available")))
  
  # Find which columns have dont_knows:
  # c = apply(coping_strategies, 2, function(x) length(which(x=="not_available")))
  # c = names(which(c>0))
  
  # Print out the remaining dataset:
  # coping_strategies = coping_strategies[coping_strategies$flag>0, c(ID_cols, c)]
  
  # Print table
  kable_styling(kable(x = coping_strategies %>% filter(flag==17), longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                      caption = "For all strategies “not_available” is selected."), "striped")

```

---

#### coping_reason
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# TODO - reduce the number of outputs columns

# Set columns of interest for distance learning:
if(population=="host"){dist_learning_cols = c(
  "distance_learning_girls_4_5", "distance_learning_girls_6_14", "distance_learning_girls_15_18",
  "distance_learning_boys_4_5", "distance_learning_boys_6_14", "distance_learning_boys_15_18")
} else {dist_learning_cols = c(
  "distance_learning_girls_3", "distance_learning_girls_4_5", "distance_learning_girls_6_14",
  "distance_learning_girls_15_18", "distance_learning_girls_19_24", "distance_learning_boys_3",
  "distance_learning_boys_4_5", "distance_learning_boys_6_14",	"distance_learning_boys_15_18",
  "distance_learning_boys_19_24")
}

# Set the cooking flue column names:
if(population=="host"){cooking_fuel_cols = c(
  "cooking_fuel.buying_lpg_refills", "cooking_fuel.firewood_purchased")
} else{cooking_fuel_cols = c(
  "alternative_cooking_fuel.buying_lpg_refills", "alternative_cooking_fuel.firewood_purchased")
}

coping_reason_inconsistency_2 <- hh_consent_daily %>% mutate(
  dist_leaning_count = rowSums(hh_consent_daily[dist_learning_cols]>0, na.rm = T),
  
  food = case_when((coping_reason.food == 1 & food_expenditure==0)~"yes", TRUE~ "no"),
  healthcare = case_when((coping_reason.healthcare == 1 & (paid_healthcare !="yes"| health_expenditure==0))~"yes", TRUE~ "no"),
  edu = case_when((coping_reason.education ==1 & dist_leaning_count==0)~"yes", TRUE~ "no"),
  edu2 = case_when((coping_reason.education ==1 & education_expenditure==0)~"yes", TRUE~ "no"),
  clothes = case_when(((coping_reason.clothing ==1 |coping_reason.hh_items==1) & infreq_nfi_expenditure==0)~"yes", TRUE~ "no"),
  # rent - added below in if statement
  shelter = case_when((coping_reason.shelter ==1 & (improvement.no_improvement == 1 | improvement.dont_know == 1 | 
                                                      improvement.other == 1 | shelter_expenditure == 0))~"yes", TRUE~ "no"),
  cookingfuel1 = case_when((coping_reason.cooking_fuel ==1 & hh_consent_daily[cooking_fuel_cols[1]] !=1 & hh_consent_daily[cooking_fuel_cols[2]] != 1)~"yes", TRUE~ "no"),
  cookingfuel2 = case_when((coping_reason.cooking_fuel ==1 & fuel_expenditure == 0)~"yes", TRUE~ "no"),
  hygiene  = case_when((coping_reason.hygiene_items ==1 & freq_nfi_expenditure == 0)~"yes", TRUE~ "no"))
  # water added below in if statement...
  # water2  = case_when((coping_reason.water ==1 & water_expenditure == 0)~"yes", TRUE~ "no"))

# Add in the bits needed for if it refugee community:
if(population=="refugee"){
  
  # water1 
  coping_reason_inconsistency_2$water1 = case_when(
    coping_reason_inconsistency_2$coping_reason.water ==1 & 
      (coping_reason_inconsistency_2$water_coping.spend_money !=1 &
         coping_reason_inconsistency_2$water_coping.buy_water !=1)~"yes", TRUE~ "no")
  # rent
  coping_reason_inconsistency_2$rent_issue = case_when((
    coping_reason_inconsistency_2$coping_reason.rent ==1 &
      (coping_reason_inconsistency_2$shelter_paid.no_need==1 |
         coping_reason_inconsistency_2$shelter_paid.dont_know==1 |
         coping_reason_inconsistency_2$shelter_paid.other==1 |
         coping_reason_inconsistency_2$rent_expenditure == 0))~"yes", TRUE~ "no")
  
} else {
  
  # water1
  coping_reason_inconsistency_2$water1 = case_when(
    (coping_reason_inconsistency_2$coping_reason.water == 1 & 
     coping_reason_inconsistency_2$water_coping.spend_money !=1)~"yes", TRUE~"no")

}

# coping_reason_inconsistency_2$coping_reason_inconsistency_2[x=="yes"] = "yes"

# Specify the columns to include, this depends on the population:
# cols = c(ID_cols, "coping_reason", "food_expenditure", 
#          "health_expenditure", "paid_healthcare", "education_expenditure", "infreq_nfi_expenditure",
#          "rent_expenditure", "shelter_expenditure", "improvement", "fuel_expenditure",
#          "freq_nfi_expenditure", "water_coping", "water_expenditure", dist_learning_cols, cooking_fuel_cols)
         
conflict_cols = c("food", "healthcare", "edu", "edu2", "clothes", "shelter", "cookingfuel1", "cookingfuel2", "hygiene", "water1") #, "water2"

caps = list(
  "food" = "== “food” & food_expenditure == 0",
  "healthcare" = "== “healthcare” & (paid_healthcare != “yes” | health_expenditure == 0)",
  "edu" = "== “education” & no children in distance learning  (or returned, if relevant)",
  "edu2" = "== “education” & education_expenditure == 0",
  "clothes" = "== (“clothing” | “hh_items”) & infreq_nfi_expenditure == 0",
  "shelter" = "== “shelter” & (improvement == “no_improvement” | improvement == “dont_know” | improvement == “other” | shelter_expenditure == 0)",
  "cookingfuel1" = "== “cooking_fuel” & fuel != “buying_lpg_refills” & fuel != “firewood_purchased” ",
  "cookingfuel2" = "== “cooking_fuel” & fuel_expenditure == 0",
  "hygiene" = "== “hygiene_items” & freq_nfi_expenditure == 0",
  "water1" = "== “water” & (water_coping != “spend_money” & water_coping != “buy_water”)") #, "water2" = "== “water” & water_expenditure == 0")


relevant_columns = list(
  "food" = c("food_expenditure"),
  "healthcare" = c("paid_healthcare", "health_expenditure"), 
  "edu" = c("dist_leaning_count", dist_learning_cols), 
  "edu2" = c("education_expenditure"), 
  "clothes" = c("coping_reason.clothing", "coping_reason.hh_items", "infreq_nfi_expenditure"), 
  # rent added below
  "shelter" = c("improvement.dont_know", "improvement.no_improvement", "improvement.other", "shelter_expenditure"), 
  "cookingfuel1" = c(cooking_fuel_cols), 
  "cookingfuel2" = c("fuel_expenditure"), 
  "hygiene" = c("freq_nfi_expenditure"), 
  "water1" = c("water_coping.spend_money")# , "water2" = c("water_expenditure")
) 
  
if(population=="refugee"){
  # cols = c(cols, "shelter_paid")
  relevant_columns$water1 = c(relevant_columns$water1, "water_coping.buy_water")
  relevant_columns$rent_issue = c("shelter_paid", "rent_expenditure")
  conflict_cols = c(conflict_cols, "rent_issue")
  caps[["rent_issue"]] = "== “rent” & (shelter_paid == “no_need” | shelter_paid == “dont_know” | shelter_paid == ”other” | rent_expenditure == 0)"
}

# coping_reason_inconsistency_2 = coping_reason_inconsistency_2 %>% filter(coping_reason_inconsistency_2=="yes") %>% select(cols)

# colnames(coping_reason_inconsistency_2) = gsub(pattern = "_", replacement = " ", x = colnames(coping_reason_inconsistency_2))
# colnames(coping_reason_inconsistency_2) = gsub(pattern = ".", replacement = ": ", x = colnames(coping_reason_inconsistency_2), fixed = T)

# Create the table print out:

for(i in names(relevant_columns)){
  
  # concol = conflict_cols[i]
  kable(x = coping_reason_inconsistency_2 %>% filter(coping_reason_inconsistency_2[i] == "yes") %>%
          select(ID_cols, coping_reason, relevant_columns[[i]]),
        longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, caption = paste(i, caps[[i]], sep = ": ")) %>%
    kable_styling("striped") %>%
    htmltools::HTML() %>%
    print

}

```

---

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# Income_source

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
#                     caption = "..."),
#               position = "center")
```

---

#### Amount Outliers
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

amounts = c("assistance_amount", "salaried_work_amount", "casual_labor_amount", "business_amount",
            "remittances_amount", "family_friends_amount", "cfw_amount", "donations_amount",
            "sale_assistance_amount", "other_amount")

if(population=="host"){amounts = c(amounts, "government_benefits_amount")}

# Sum the amounts:
hh_consent_full$total_amount = rowSums(x = hh_consent_full[,amounts], na.rm = TRUE)

# Set up a matrix to hold the stats:
amounts = matrix(ncol = length(amounts)+1,
                 nrow = 4, data = NA, 
                 dimnames = list(c("mean", "SD", "mean-2SD", "mean+2SD"), 
                                 c(amounts, "total_amount")))

# Extract all of the expenditure data: 
amounts_data <- hh_consent_full[,colnames(amounts)]

# Compute the stats:
for(e in colnames(amounts)){
  amounts[1,e] = mean(amounts_data[,e], na.rm = TRUE)
  amounts[2,e] = sd(x = amounts_data[,e], na.rm = TRUE)
  amounts[3,e] = amounts[1,e] - 2*amounts[2,e]
  amounts[4,e] = amounts[1,e] + 2*amounts[2,e]
} # The above makes NaN and NA values, though I do not think that will affect anything.

# Round the values to 0 decimal places:
amounts = round(amounts,0)
# Print the stats table:
kable_styling(kable(x = amounts, longtable = T, booktabs = T, linesep = "", align = "c", row.names = TRUE, 
                    caption = "Amount statistics."), "striped") 

# Calculate the daily amount totals:
hh_consent_daily$total_amount <- rowSums(hh_consent_daily[, colnames(amounts)[1:(ncol(amounts)-1)]], na.rm = TRUE)

# Create a subset of the data to use for calculations
amounts_data_day <- hh_consent_daily[, c(ID_cols, colnames(amounts))]


# Find instances in the daily data where values are outliers:
amounts_data_day <- amounts_data_day %>% mutate(
  
  assistance = case_when((assistance_amount < amounts[3, "assistance_amount"] | 
                             assistance_amount > amounts[4, "assistance_amount"])~"yes", TRUE~"no"),
  
  salaried_work = case_when((salaried_work_amount < amounts[3, "salaried_work_amount"] | 
                         salaried_work_amount > amounts[4, "salaried_work_amount"])~"yes", TRUE~"no"),
  
  casual_labor = case_when((casual_labor_amount < amounts[3, "casual_labor_amount"] | 
                             casual_labor_amount > amounts[4, "casual_labor_amount"])~"yes", TRUE~"no"),
  
  business = case_when(((business_amount < amounts[3, "business_amount"] | 
                           business_amount > amounts[4, "business_amount"]))~"yes", TRUE~"no"),
  
  remittances = case_when(((remittances_amount < amounts[3, "remittances_amount"] |
                              remittances_amount > amounts[4, "remittances_amount"]))~"yes", TRUE~"no"),
  
  family_friends = case_when(((family_friends_amount < amounts[3, "family_friends_amount"] |
                                 family_friends_amount > amounts[4, "family_friends_amount"]))~"yes", TRUE~"no"),
  
  cfw = case_when((cfw_amount < amounts[3, "cfw_amount"] |
                      cfw_amount > amounts[4, "cfw_amount"])~"yes", TRUE~"no"),
  
  donations = case_when((donations_amount < amounts[3, "donations_amount"] |
                      donations_amount > amounts[4, "donations_amount"])~"yes", TRUE~"no"),
  
  sale_assistance = case_when((sale_assistance_amount < amounts[3, "sale_assistance_amount"] | 
                              sale_assistance_amount > amounts[4, "sale_assistance_amount"])~"yes",
                          TRUE~"no"),
  other = case_when((other_amount < amounts[3, "other_amount"] |
                        other_amount > amounts[4, "other_amount"])~"yes", TRUE~"no"),
  
  total = case_when((total_amount < amounts[3, "total_amount"] | total_amount > amounts[4, "total_amount"])~"yes", TRUE~"no"))
  

# If it is HC, calculate where daily values are outliers:
if(population=="host"){
  amounts_data_day <- amounts_data_day %>% mutate(
    government_benefits = case_when(
    (hh_consent_daily$government_benefits_amount < amounts[3, (ncol(amounts)-1)] |
       hh_consent_daily$government_benefits_amount > amounts[4, (ncol(amounts)-1)])~"yes", TRUE~"no"))
}

# Select the columns desired from the amounts_data_day:
amounts_data_day = amounts_data_day %>% select(c(ID_cols, 
           colnames(amounts), gsub(pattern = "_amount", replacement = "", x = colnames(amounts))))


# Print the tables:
for(i in 1:ncol(amounts)){
  
  concol = gsub(pattern = "_amount", replacement = "", x = colnames(amounts))[i]

  kable(x = amounts_data_day %>% filter(amounts_data_day[concol] == "yes") %>%
          select(ID_cols, colnames(amounts)[i], concol),
        longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, caption = 
          paste0(concol, "   |  Lower limit is ", round(amounts[3,paste0(concol, "_amount")], 0),
                 ". Upper limit is ", round(amounts[4,paste0(concol, "_amount")], 0))) %>%
    kable_styling("striped") %>%
    htmltools::HTML() %>%
    print

}

```

---

#### main_income_source.humanitarian_assistance == 0
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
if(population=="refugee"){
kable_styling(kable(x = hh_consent_daily[hh_consent_daily$main_income_source.humanitarian_assistance==0,
                                           c(ID_cols, "main_income_source.humanitarian_assistance")],
      longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
      caption = "main_income_source.humanitarian_assistance == 0"),
      "striped")
}
```

---

#### Checks of the following PER CAPITA: 

food_expenditure, rent_expenditure , water_expenditure, freq_nfi_expenditure, fuel_expenditure, transportation_expenditure.
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

amounts2 = c("food_expenditure", "rent_expenditure" , "freq_nfi_expenditure", "fuel_expenditure", "transportation_expenditure")# "water_expenditure", 

# TODO - not working
  # rent_expenditure_inconsistency <- hh_consent_daily %>% mutate(
  #   rent_expenditure_inconsistency = case_when((hh$rent_expenditure>0 & hh$shelter_type)~"yes", T~NA_character_))

# Sum the amounts:
hh_consent_full$total_expenditure = rowSums(x = hh_consent_full[,amounts2], na.rm = TRUE) 

# Set up a matrix to hold the stats:
amounts2 = matrix(ncol = length(amounts2)+1,
                 nrow = 4, data = NA, 
                 dimnames = list(c("mean", "SD", "mean-2SD", "mean+2SD"), 
                                 c(amounts2, "total_expenditure")))

# Extract all of the expenditure data PER CAPITA (per person): 
amounts2_data <- hh_consent_full[,colnames(amounts2)] / hh_consent_full$hh_size

# Compute the stats:
for(e in colnames(amounts2)){
  amounts2[1,e] = mean(amounts2_data[,e], na.rm = TRUE)
  amounts2[2,e] = sd(x = amounts2_data[,e], na.rm = TRUE)
  amounts2[3,e] = amounts2[1,e] - 2*amounts2[2,e]
  amounts2[4,e] = amounts2[1,e] + 2*amounts2[2,e]
} # The above makes NaN and NA values, though I do not think that will affect anything.

# Calculate the daily amount totals:
hh_consent_daily$total_expenditure <- rowSums(hh_consent_daily[, colnames(amounts2)[1:(ncol(amounts2)-1)]], na.rm = TRUE)

# Create a subset of the data to use for calculations
amounts2_data_day <- hh_consent_daily[, colnames(amounts2)]

# Store the origional data:
amounts2_data_day_origional = amounts2_data_day[colnames(amounts2)]
colnames(amounts2_data_day_origional) = paste0("ORIGIONAL_", colnames(amounts2_data_day_origional))
                                       
# Convert to per Capita:
amounts2_data_day = round(amounts2_data_day[colnames(amounts2)] / hh_consent_daily$hh_size, 0)

# c("food_expenditure", "rent_expenditure" , "water_expenditure", "freq_nfi_expenditure", "fuel_expenditure", "transportation_expenditure")
# Find instances in the daily data where values are outliers:
amounts2_data_day <- amounts2_data_day %>% mutate(
  
  food = case_when((food_expenditure < amounts2[3, "food_expenditure"] | 
                      food_expenditure > amounts2[4, "food_expenditure"])~"yes", TRUE~"no"),
  
  rent = case_when((rent_expenditure < amounts2[3, "rent_expenditure"] | 
                      rent_expenditure > amounts2[4, "rent_expenditure"])~"yes", TRUE~"no"),
  
  # water = case_when((water_expenditure < amounts2[3, "water_expenditure"] | 
  #                      water_expenditure > amounts2[4, "water_expenditure"])~"yes", TRUE~"no"),
  
  freq_nfi = case_when(((freq_nfi_expenditure < amounts2[3, "freq_nfi_expenditure"] | 
                           freq_nfi_expenditure > amounts2[4, "freq_nfi_expenditure"]))~"yes", TRUE~"no"),
  
  fuel = case_when(((fuel_expenditure < amounts2[3, "fuel_expenditure"] |
                       fuel_expenditure > amounts2[4, "fuel_expenditure"]))~"yes", TRUE~"no"),
  
  transportation = case_when(((transportation_expenditure < amounts2[3, "transportation_expenditure"] |
                            transportation_expenditure > amounts2[4, "transportation_expenditure"]))~"yes", TRUE~"no"),
  
  total = case_when((total_expenditure < amounts2[3, "total_expenditure"] |
                       total_expenditure > amounts2[4, "total_expenditure"])~"yes", TRUE~"no")) 

amounts2_data_day = cbind(hh_consent_daily[, c(ID_cols)],
                          amounts2_data_day)

amounts2_data_day = amounts2_data_day %>%
  select(c(ID_cols, 
           colnames(amounts2), gsub(pattern = "_expenditure", replacement = "", x = colnames(amounts2))))



# Print the tables:
for(i in 1:ncol(amounts2)){
  
  concol = gsub(pattern = "_expenditure", replacement = "", x = colnames(amounts2))[i]
  
  # Select per Capita data:
  x = amounts2_data_day %>%
          select(ID_cols, colnames(amounts2)[i], concol)
  
  # Add on the origional data:
  c = paste0("ORIGIONAL_",concol, "_expenditure")
  x[c] = amounts2_data_day_origional[,c]
  
  # Filter this to the rows of interest:
  x = x[x[concol] == "yes",] 
    
  kable(x,
        longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, caption = 
          paste0(concol, "   |  Lower limit is ", round(amounts2[3,paste0(concol, "_expenditure")], 0),
                 ". Upper limit is ", round(amounts2[4,paste0(concol, "_expenditure")], 0))) %>%
    kable_styling("striped") %>%
    htmltools::HTML() %>%
    print

}
```

---

food_assistance_value, freq_nfi_assistance_value, fuel_assistance_value, transportation_assistance_value
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

amounts3 = c("food_assistance_value", "freq_nfi_assistance_value" , "fuel_assistance_value", "transportation_assistance_value")

# Sum the amounts:
hh_consent_full$total_value = rowSums(x = hh_consent_full[,amounts3], na.rm = TRUE) 

# Set up a matrix to hold the stats:
amounts3 = matrix(ncol = length(amounts3)+1,
                 nrow = 4, data = NA, 
                 dimnames = list(c("mean", "SD", "mean-2SD", "mean+2SD"), 
                                 c(amounts3, "total_value")))

# Extract all of the expenditure data PER CAPITA (per person): 
amounts3_data <- hh_consent_full[,colnames(amounts3)] / hh_consent_full$hh_size

# Compute the stats:
for(e in colnames(amounts3)){
  amounts3[1,e] = mean(amounts3_data[,e], na.rm = TRUE)
  amounts3[2,e] = sd(x = amounts3_data[,e], na.rm = TRUE)
  amounts3[3,e] = amounts3[1,e] - 2*amounts3[2,e]
  amounts3[4,e] = amounts3[1,e] + 2*amounts3[2,e]
} # The above makes NaN and NA values, though I do not think that will affect anything.

# Calculate the daily amount totals:
hh_consent_daily$total_value <- rowSums(hh_consent_daily[, colnames(amounts3)[1:(ncol(amounts3)-1)]], na.rm = TRUE)

# Create a subset of the data to use for calculations
amounts3_data_day <- hh_consent_daily[, colnames(amounts3)]

# Store the origional data:
amounts3_data_day_origional = amounts3_data_day[colnames(amounts3)]
colnames(amounts3_data_day_origional) = paste0("Origional_", colnames(amounts3_data_day_origional))
                                       
# Convert to per Capita:
amounts3_data_day = round(amounts3_data_day[colnames(amounts3)] / hh_consent_daily$hh_size, 0)

# Find instances in the daily data where values are outliers:
amounts3_data_day <- amounts3_data_day %>% mutate(
  
  food_assistance = case_when((food_assistance_value < amounts3[3, "food_assistance_value"] | 
                                       food_assistance_value > amounts3[4, "food_assistance_value"])~"yes", TRUE~"no"),
  
  freq_nfi_assistance = case_when((freq_nfi_assistance_value < amounts3[3, "freq_nfi_assistance_value"] | 
                                     freq_nfi_assistance_value > amounts3[4, "freq_nfi_assistance_value"])~"yes", TRUE~"no"),
  
  fuel_assistance = case_when(((fuel_assistance_value < amounts3[3, "fuel_assistance_value"] | 
                                      fuel_assistance_value > amounts3[4, "fuel_assistance_value"]))~"yes", TRUE~"no"),
  
  transportation_assistance = case_when(((transportation_assistance_value < amounts3[3, "transportation_assistance_value"] |
                                            transportation_assistance_value > amounts3[4, "transportation_assistance_value"]))~"yes", TRUE~"no"),
  
  total = case_when((total_value < amounts3[3, "total_value"] |
                       total_value > amounts3[4, "total_value"])~"yes", TRUE~"no")) 


# Add on the identifier data:
amounts3_data_day = cbind(hh_consent_daily[, c(ID_cols)],
                          amounts3_data_day)

amounts3_data_day = amounts3_data_day %>%
  select(c(ID_cols, 
           colnames(amounts3), gsub(pattern = "_value", replacement = "", x = colnames(amounts3))))



# Print the tables:

for(i in 1:ncol(amounts3)){
  
  concol = gsub(pattern = "_value", replacement = "", x = colnames(amounts3))[i]
  
  # Select per Capita data:
  x = amounts3_data_day %>%
          select(ID_cols, colnames(amounts3)[i], concol)
  
  # Add on the origional data:
  c = paste0("Origional_",concol, "_value")
  x[c] = amounts3_data_day_origional[,c]
  
  # Filter this to the rows of interest:
  x = x[x[concol] == "yes",] 
    
  kable(x,
        longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, caption = 
          paste0(concol, "   |  Lower limit is ", round(amounts3[3,paste0(concol, "_value")], 0),
                 ". Upper limit is ", round(amounts3[4,paste0(concol, "_value")], 0))) %>%
    kable_styling("striped") %>%
    htmltools::HTML() %>%
    print

}
```

---

#### food_expenditure and food_assistance_value
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# sum food_expenditure & food_assistance_value
food_value = hh_consent_daily[c("food_expenditure", "food_assistance_value")]
food_value$sum = rowSums(food_value, na.rm = TRUE)

# Flag if these == 0 or (for camps) if food_assistance_value == 0:
if(population=="host"){food_value$flag = food_value$sum==0}
if(population=="refugee"){food_value$flag = (food_value$sum==0 | food_value$food_assistance_value==0)}

# print the table
food_value = cbind(hh_consent_daily[c(ID_cols)], food_value)
kable_styling(kable(x = food_value[which(food_value$flag==TRUE),],
      longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
      caption = "Flag if sum of food_expenditure & food_assistance_value == 0, and for camps also if food_assistance_value == 0 "),
      "striped")
```

---

#### rent_expenditure
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

if(population=="refugee"){
  rent_expenditure_issue = hh_consent_daily %>% mutate(
    conflict = case_when((
      (rent_expenditure > 0 & shelter_paid.payment_of_cash != 1) |
      (rent_expenditure == 0 & shelter_paid.payment_of_cash == 1))~"yes", T~ NA_character_)) %>%
    filter(conflict=="yes") %>% 
    select(ID_cols, shelter_paid, rent_expenditure)
  
  kable_styling(kable(x = rent_expenditure_issue, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                      caption = "rent_expenditure and payment of cash"),
                position = "center")
}

```

---

#### fuel_expenditure
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# This uses cooking cols from an earlier chunk, which depend of HC/RC.

fuel_expenditure_inconsistency <- hh_consent_daily %>% mutate(
  fuel_expend_inconsistency = case_when(
    (fuel_expenditure> 0 & (hh_consent_daily[,cooking_fuel_cols[1]] != 1 & hh_consent_daily[,cooking_fuel_cols[2]] !=1))|
      (fuel_expenditure== 0 & (hh_consent_daily[,cooking_fuel_cols[1]] == 1 | hh_consent_daily[,cooking_fuel_cols[1]] ==1))~ "yes", T~ "no")) %>% 
  filter(fuel_expend_inconsistency=="yes") %>% 
  select(ID_cols, fuel_expenditure, cooking_fuel_cols, fuel_expend_inconsistency)

kable_styling(kable(x = fuel_expenditure_inconsistency, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption = "fuel_expenditure_inconsistency"),
              position = "center")
```

---

#### Expenditure:

Should flag unusually high/low values for each and the sum. [Per capita]
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

expenditures = c("shelter_expenditure", "infreq_nfi_expenditure", "health_expenditure", "education_expenditure", "livelihood_expenditure", "debt_expenditure")

# Sum the expenditures per capita:
hh_consent_full$total_expenditure = rowSums(hh_consent_full[,expenditures], na.rm = TRUE) 

# Set up a matrix to hold the stats:
expenditures = matrix(ncol = length(expenditures)+1, nrow = 4, data = NA, 
                      dimnames = list(c("mean", "SD", "mean-2SD", "mean+2SD"), 
                                      c(expenditures, "total_expenditure")))


# Extract all of the expenditure data per Capita: 
expenditures_data <- hh_consent_full[,colnames(expenditures)] / hh_consent_full$hh_size


# Compute the stats:
for(e in colnames(expenditures)){
  expenditures[1,e] = mean(expenditures_data[,e], na.rm = TRUE)
  expenditures[2,e] = sd(x = expenditures_data[,e], na.rm = TRUE)
  expenditures[3,e] = expenditures[1,e] - 2*expenditures[2,e]
  expenditures[4,e] = expenditures[1,e] + 2*expenditures[2,e]
}


# Run through the daily dataset and find instances where this values are outliers:
hh_consent_daily$total_expenditure <- rowSums(hh_consent_daily[, colnames(expenditures)[1:6]], na.rm = TRUE)

expenditures_data_day <- hh_consent_daily[, c(ID_cols,  colnames(expenditures))]

# Store the original data:
expenditures_data_day_origional = expenditures_data_day
colnames(expenditures_data_day_origional) = paste0("Origional_", colnames(expenditures_data_day_origional))

# Make sure that this is per capita:
expenditures_data_day[colnames(expenditures)] = expenditures_data_day[colnames(expenditures)] / hh_consent_daily$hh_size

# Round the data to 0 Decimal places:
expenditures_data_day[grep(pattern = "expenditure", x = colnames(expenditures_data_day))] = 
  round(expenditures_data_day[grep(pattern = "expenditure", x = colnames(expenditures_data_day))], 0)

expenditures_data_day <- expenditures_data_day %>% mutate(
  
  shelter_exp = case_when((shelter_expenditure < expenditures[3, "shelter_expenditure"] | 
                             shelter_expenditure > expenditures[4, "shelter_expenditure"])~"yes", TRUE~"no"),
 
  infreq_nfi_exp = case_when((infreq_nfi_expenditure < expenditures[3, "infreq_nfi_expenditure"] |
                                infreq_nfi_expenditure > expenditures[4, "infreq_nfi_expenditure"])~"yes", TRUE~"no"),
  
  health_exp = case_when((health_expenditure < expenditures[3, "health_expenditure"] |
                            health_expenditure > expenditures[4, "health_expenditure"])~"yes", TRUE~"no"),
  
  livelihood_exp = case_when((livelihood_expenditure < expenditures[3, "livelihood_expenditure"] |
                               livelihood_expenditure > expenditures[4, "livelihood_expenditure"])~"yes", TRUE~"no"),
  
  education_exp = case_when((education_expenditure < expenditures[3, "education_expenditure"] |
                               education_expenditure > expenditures[4, "education_expenditure"])~"yes", TRUE~"no"),
  
  debt_exp = case_when((debt_expenditure < expenditures[3, "debt_expenditure"] | 
                          debt_expenditure > expenditures[4, "debt_expenditure"])~"yes", TRUE~"no"),
  
  total_exp  = case_when((total_expenditure < expenditures[3, "total_expenditure"] | 
                            total_expenditure > expenditures[4, "total_expenditure"])~"yes", TRUE~"no"))

# expenditures_data_day = expenditures_data_day[expenditures_data_day$outlier=="yes",]
# expenditures_data_day$outlier <- NULL

# colnames(expenditures_data_day) = gsub(x = colnames(expenditures_data_day), pattern = "_", replacement = " ")

kable_styling(kable(x = round(expenditures, 0), longtable = T, booktabs = T, linesep = "", align = "c", row.names = TRUE,
                    caption = "Expenditure statistics"),
              position = "center")

cols = colnames(expenditures_data_day)
relevant_cols = cols[grep(pattern = "expenditure", x = cols)]
cols = cols[grep(pattern = "exp", x = cols)]; cols = unique(gsub(pattern = "expenditure", replacement = "exp", x = cols))



for(i in 1:length(cols)){
  
  concol = cols[i]
  
  # Select per Capita data:
  x = expenditures_data_day %>% # %>% filter(expenditures_data_day[concol] == "yes") 
          select(ID_cols, relevant_cols[i], concol)

  # Add on the original data:
  c = paste0("Origional_", substr(x = concol, start = 1, stop = nchar(concol)-4), "_expenditure")
  x[c] = expenditures_data_day_origional[,c]

  # Filter this to the rows of interest:
  x = x[x[concol] == "yes",]
  
  kable(x = x,
        longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, 
        caption = paste0(concol, ":  Upper limit is ", round(expenditures[4,relevant_cols[i]], 0))) %>%
    kable_styling("striped") %>%
    htmltools::HTML() %>%
    print

}



```

---

#### health_expenditure

health_expenditure > 0 & paid_healthcare == “no” OR health_expenditure == 0 & paid_healthcare == “yes”.
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

health_expenditure_inconsistency<- hh_consent_daily %>% mutate(
  health_expenditure_inconsistency= case_when((health_expenditure>0 & paid_healthcare=="no")|
                                               (health_expenditure==0 & paid_healthcare=="yes")~"yes",
                                              T~NA_character_))%>% 
  filter(health_expenditure_inconsistency=="yes") %>% 
  select(ID_cols, paid_healthcare, health_expenditure)

kable_styling(kable(x = health_expenditure_inconsistency, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption = "health_expenditure_inconsistency"),
              position = "center")
```

---

#### shelter_expenditure

shelter expenditure > 0 & shelter_materials_source != “purchased” OR shelter_expenditure == 0 & shelter_materials_source == “purchased”.
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

shelter_expenditure_inconsistency <- hh_consent_daily %>% mutate(
  shelter_expenditure_inconsistency= case_when((shelter_expenditure>0 & shelter_materials_source.purchased==0)|
                                                 (shelter_expenditure==0 &shelter_materials_source.purchased==1)~"yes",
                                               T~ NA_character_))%>% 
  filter(shelter_expenditure_inconsistency=="yes") %>% 
  select(ID_cols, shelter_expenditure, shelter_materials_source)

kable_styling(kable(x = shelter_expenditure_inconsistency, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption = "shelter_expenditure_inconsistency"),
              position = "center")
```

---

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# # sanitation_coping # Removed from list of checks
# 
# sanitation_coping_inconsistency <- hh_consent_daily %>% mutate(
#   sanitation_coping_inconsistency = case_when((sanitation_coping.no_issue==1 & sanitation_barriers_female.no_problem==0 &
#                                                  sanitation_barriers_male.no_problem==0 )|
#                                                ((sanitation_coping.no_issue==0 & 
#                                                    (sanitation_barriers_female.no_problem==1 |
#                                                       sanitation_barriers_female.no_problem== NA) &
#                                                    (sanitation_barriers_male.no_problem==1 |
#                                                       sanitation_barriers_male.no_problem==NA)))~"yes", T~ NA_character_)) %>%
#   select(ID_cols,sanitation_coping,sanitation_barriers_male,sanitation_barriers_female,sanitation_coping_inconsistency) %>% 
#   filter(sanitation_coping_inconsistency=="yes")
# 
# kable_styling(kable(x = sanitation_coping_inconsistency, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
#                     caption = "sanitation_coping_inconsistency"),
#               position = "center")
```

---

#### group_water_quantity.
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

group_water_quantity = hh_consent_daily %>% mutate(
  bathing = case_when((enough_water_bathing_facility == "not_applicable" & enough_water_bathing_shelter == "not_applicable")~"yes",
                                   T~ NA_character_),
  Not_applicables = case_when((enough_water_drinking == "not_applicable" | enough_water_cooking == "not_applicable" | enough_water_other == "not_applicable")~"yes",
                                   T~ NA_character_)) 

kable_styling(kable(x = group_water_quantity %>% filter(bathing=="yes") %>%
                      select(ID_cols,
                             sanitation_coping, enough_water_bathing_facility, enough_water_bathing_shelter),
                    longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption = "Flag if 'enough_water_bathing_facility' AND 'enough_water_bathing_shelter' are 'not_applicable'."),
              position = "center")

kable_styling(kable(x = group_water_quantity %>% filter(Not_applicables=="yes") %>%
                      select(ID_cols,
                             sanitation_coping, enough_water_drinking, enough_water_cooking, enough_water_other),
                    longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption = "Flag if drinking water, cooking water, or water for other domestic purposes are not applicable"),
              position = "center")


```

---

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# child_needs

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
#                     caption = "..."),
#               position = "center")
```


```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
### Outliers check
# TODO
# Cara wants the mean and SD at several points. This function will do this automatically.
# There is more code on this in the daily monitoring script in the rATA script.

# outliers_check_hh <- outlier_check(df = hh_consent_daily, kobo_tool_location = "../01_DAP/tool/host/Host_JMSNA_2021_v8.xlsx",
#                                    cols_to_report = c("X_uuid", "enumerator_id"))# , include_multiple_choices = FALSE)
# 
# outliers_check_indv <- outlier_check(df = indv_daily_data,kobo_tool_location = "01_DAP/tool/host/Host_JMSNA_2021_v8.xlsx",
# cols_to_report = c("X_uuid"),include_multiple_choices = FALSE)


```



## 5. Other response
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# Find the columns of interest for HH data:
hh_other_cols <- hh_consent_daily %>% select(c(starts_with("other_"), ends_with("_other"))) %>% names()

# Exclude the following columns
hh_other_cols = hh_other_cols[!hh_other_cols %in% c("other_amount", "other_amount_dk", "other_distribution", 
                                                    "other_distribution.not_enough", "other_distribution.less_preferred", "other_distribution.quality",
                                                    "water_coping.less_preferred_other", "water_coping.less_use_other", "enough_water_other")]

# Include the following additional columns:
hh_other_cols = c(hh_other_cols, "unsafe_areas_male_shelter", "unsafe_areas_female_shelter")

# Subset the data to just the columns with other data:
hh_other <- hh_consent_daily %>%
  filter_at(vars(hh_other_cols), any_vars(!is.na(.))) %>%
  select(ID_cols, hh_other_cols)

# # I think this is done by the filter above, so is not needed:
#   # Find which rows have "other" answers: 
#   include = rowSums(!is.na(hh_other[, hh_other_cols]))
#   # Remove all rows without "other" answers:
#   hh_other = hh_other[which(include>0),]

if(nrow(hh_other)>0){
  
  # Find which columns have "other" answers: 
  include = colSums(!is.na(hh_other[, hh_other_cols]))
  # Remove all rows without "other" answers:
  hh_other[, hh_other_cols[include==0]] = NULL
  
  # Convert to long table:
  hh_other[] <- lapply(hh_other, as.character)
  
  hh_other_pi_long <- hh_other %>% 
    pivot_longer(-c(ID_cols),
                 names_to = "questions", values_to = "old_value") %>%  group_by(X_uuid)
  
  hh_other_pi_long <- hh_other_pi_long %>% filter(!is.na(old_value))
  
  # Print table:
  kable_styling(kable(x = hh_other_pi_long, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                      caption = "Household 'Other' answers"), position = "center")
  
  # Write the table to a csv:
  write.csv(x = hh_other_pi_long, file = paste0("05_outputs/01_daily_monitoring/", population, "/Reports/Daily Monitoring Report - Other HH Responses - ",
                                                population,  " - ", gsub("-", "_", day_to_run), ".csv"))

  } else {print("No 'other' responses in household data.")}


# ----
# Repeat for individual tab:

# Find the columns of interest for individual data:
ind_other_cols <- indv_daily_data %>%  select(c(starts_with("other_"), ends_with("_other"))) %>% names()

# Subset the data to just the columns with other data:
ind_other <- indv_daily_data %>%
  filter_at(vars(ind_other_cols), any_vars(!is.na(.))) %>%
  select(X_uuid, parent_instance_name, repeat_instance_name, ind_other_cols)

if(nrow(ind_other)>0){
  
  kable_styling(kable(x = ind_other, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                      caption = "Infividual 'Other' answers"), position = "center")
} else {print("No 'other' responses in Individual data.")}



# cleaning_log_other <- bind_rows(hh_other_pi_long, ind_other_pi_long) %>% select(reported_date, X_uuid, survey_loop, repeat_instance_name, everything())
# 
# all_cleaning_log[["other_respose_cl"]] <- cleaning_log_other
# 

```

---

#### 3.f.	Number of issues flagged by enumerator:
[needs an update once all checks are added and confirmed working]
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

enumerator_list = c(
  check_duplicate_respondent_id$enumerator_id,
  dont_know_more_than_15$enumerator_id,
  individuals_difficulties$enumerator_id,
  shelter_issues_reason_inconsistency$enumerator_id,
  improvement_reason_inconsistency$`enumerator id`,
  improvement_reason_inconsistency2$enumerator_id,
  improvement_reason_inconsistency2b$enumerator_id,
  group_nfi_inconsistency$reported_date,
  health_distance_inconsistensy$`enumerator id`,
  health_service_inconsistency$`enumerator id`,
  LI_dist_learning_barriers_girls$enumerator_id,
  LI_dist_learning_barriers_boys$enumerator_id,
  send_back_barriers_girls$enumerator_id,
  LI_send_back_barriers_boys$enumerator_id,
  send_back_challenges_girls$enumerator_id,
  send_back_challenges_boys$enumerator_id,
  nutrition_barriers_not_accessed_inconsistency$`enumerator id`,
  # plw$enumerator_id,
  # food_barriers$enumerator_id,
  # group_livelihood_coping_inconsistency$`enumerator id`,
  coping_reason_inconsistency_2$`enumerator id`,
  amounts_data_day$`enumerator id`,
  # amounts_data_day2$`enumerator id`,
  # rent_expenditure_issue$enumerator_id,
  fuel_expenditure_inconsistency$`enumerator id`,
  expenditures_data_day$`enumerator id`,
  health_expenditure_inconsistency$enumerator_id,
  shelter_expenditure_inconsistency$enumerator_id,
  # sanitation_coping_inconsistency$enumerator_id,
  group_water_quantity$`enumerator id`
  )

if(population=="host"){enumerator_list = c(enumerator_list, admin_missmatch$enumerator_id, age_missmatch$enumerator_id)}
if(population=="refugee"){enumerator_list = c(enumerator_list, FCN_missmatch$enumerator_id)} # do the same for camps
if(eval_audit==TRUE){enumerator_list = c(enumerator_list, survey_time$enumerator_id, duration_df3$enumerator_id)}

# count(enumerator_list)
count = table(enumerator_list)
count = count[order(count, decreasing = TRUE)]
# freq = freq[,order(freq)]

kable_styling(kable(x = count, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption= "Number of issues flagged per enumerator (not all checks included yet):"),
              position = "center")

```


#### Enumerator dont_know
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# Create a subset of the dataset:
dont_knows = colnames(hh_consent_daily)[grep(pattern = "_dk", x = colnames(hh_consent_daily))]
dont_knows = hh_consent_daily[c(ID_cols, dont_knows)]

# Find which rows have dont_knows:
dont_knows$flag = apply(dont_knows, 1, function(x) length(which(x=="dont_know")))

# Find which columns have dont_knows:
c = apply(dont_knows, 2, function(x) length(which(x=="dont_know")))
c = names(which(c>0))

# Print out the remaining dataset:
dont_knows = dont_knows[dont_knows$flag>0, c(ID_cols,c)]

kable_styling(kable(x = dont_knows, longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE,
                    caption= "Answers to '_dk' questions"), position = "center")

if(nrow(dont_knows)>0){
kable_styling(kable(x = table(dont_knows$enumerator_id), longtable = T, booktabs = T, linesep = "", align = "c", row.names = FALSE, 
                    col.names = c("Enumerator ID", "dont_know count"), caption= "Answers to '_dk' questions"), position = "center")
}


```

---

```{r eval=FALSE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE, include= FALSE}
## cleaning log
# cleaning log will be provided in separate excel file. This is currently not being written as deemed unnecessary for now.
all_cleaning_log$duration_cl$old_value <- all_cleaning_log$duration_cl$old_value %>% as.character()
final_cleaning_log <- do.call("bind_rows", all_cleaning_log)

final_cleaning_log <- final_cleaning_log %>% mutate(new_value =NULL, change_type=NULL) %>%
  select(ID_cols, survey_loop, questions, old_value, everything())

final_cleaning_log <- final_cleaning_log %>% rename("issues"="ref_col")

final_cleaning_log$reported_date <- final_cleaning_log$reported_date %>% lubridate::as_date()

final_cleaning_log <- final_cleaning_log %>% filter(reported_date == day_to_run)  #### Output daily cleaning log only



# work_book ---------------------------------------------------------------

final_cleaning_log_for_excel <- final_cleaning_log %>% mutate(
  unique_col = paste0(X_uuid, "_",issues)
)


headerStyle <- createStyle(fontSize = 12, 
                           fontColour = "#FFFFFF",
                           halign = "center",
                           valign = "center",
                           fontName = "Arial Narrow",
                           textDecoration = "bold",
                           fgFill = "#ee5859",
                           border = "TopBottomLeftRight ",
                           borderColour = "#fafafa",
                           wrapText = T,numFmt = "DATE"
)
bodyStyle <- createStyle(fontSize = 11, 
                         fontName = "Arial Narrow",
                         border = "TopBottomLeftRight ",
                         borderColour = "#4F81BD",
                         valign = "center",
                         halign = "left",
)


wb <- createWorkbook()
addWorksheet(wb, "cleaning log")
writeData(wb, sheet = 1, final_cleaning_log_for_excel, rowNames = F)

u = unique(final_cleaning_log_for_excel$unique_col)

for(x in u){
  y = which(final_cleaning_log_for_excel$unique_col == 3)
  
  mergeCells(wb, sheet = 1, cols = 1, rows = y+1 )
  mergeCells(wb, sheet = 1, cols = 2, rows = y+1)
  mergeCells(wb, sheet = 1, cols = 3, rows = y+1)
  mergeCells(wb, sheet = 1, cols = 4, rows = y+1)
  mergeCells(wb, sheet = 1, cols = 5, rows = y+1)
  mergeCells(wb, sheet = 1, cols = 6, rows = y+1)
  mergeCells(wb, sheet = 1, cols = 7, rows = y+1)
  mergeCells(wb, sheet = 1, cols = 10, rows = y+1)
  
}

addFilter(wb,sheet =  1, row = 1, cols = 1:ncol(final_cleaning_log_for_excel))
freezePane(wb, sheet = 1, firstCol = TRUE, firstRow = T)


addStyle(wb, sheet = 1, headerStyle, rows = 1, cols = 1:ncol(final_cleaning_log_for_excel), gridExpand = TRUE)
addStyle(wb, sheet = 1, bodyStyle, rows = 1:nrow(final_cleaning_log_for_excel)+1, cols = 1:ncol(final_cleaning_log_for_excel), gridExpand = TRUE)

setColWidths(wb, 1, cols = 1:ncol(final_cleaning_log_for_excel), widths = 25) 

##### color #####

for(x in u){
y = which(final_cleaning_log_for_excel$unique_col == x)

random.color <- randomColor(1, luminosity = "light") 

sty_date <- createStyle(numFmt = "dd/mm/yyyy",
                             fgFill=random.color,
                             fontSize = 11, 
                             fontName = "Arial Narrow",
                             border = "TopBottomLeftRight ",
                             borderColour = "#4F81BD",
                             valign = "center",
                             halign = "left")

style <- createStyle(fgFill=random.color,
                     fontSize = 11, 
                     fontName = "Arial Narrow",
                     border = "TopBottomLeftRight ",
                     borderColour = "#4F81BD",
                     valign = "center",
                     halign = "left",)
addStyle(wb, 1, style = sty_date, rows = y+1, cols = 1:1, gridExpand = T)
addStyle(wb, sheet = 1, style, rows = y+1, cols = 2:ncol(final_cleaning_log_for_excel), gridExpand = TRUE)

}

setColWidths(wb, 1, cols = which(names(final_cleaning_log_for_excel)== "unique_col"),hidden = T) 
##############################################


saveWorkbook(wb, file = paste0(cleaning_log_path, gsub(x = day_to_run, pattern = "-", replacement = ""), "_", "cleaning_log_", population, ".xlsx"), overwrite = TRUE)


```


