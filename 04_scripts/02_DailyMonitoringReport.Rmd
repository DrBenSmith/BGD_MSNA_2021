---
title: "`Daily Monitoring Report`"
author: "BGD GIS DATA UNIT - Ben Smith"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
html_document:
code_folding: hide
---


```{r For_Testing, echo=FALSE}
# --- Testing:
# The following snippet should be used for testing, then removed for the actual runs:
population<-c("host","refugee")[2]
write_csv_output<-c("yes","no")[2]
day_to_run <- Sys.Date()-1
```

```{r Libraries, echo=FALSE, include=FALSE, warning = FALSE, message=FALSE}
# Preamble for setting up the data collection:

# Set the default chuck settings:
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning = FALSE)

# Load in libraries ... Surely these are more than we need?
library(tidyr) # used for pivot_longer
library(dplyr)
library(stringr)
library(lubridate) # (for ymd, remove dependence if possible)
library(kableExtra) # install.packages("kableExtra")
library(readxl)
library(openxlsx)
# library("tools") 
source("functions/Load_Audit.R")
source("functions/utils.R")
source("active_path.R")
# library(ggplot2)
# library(rgdal)
# library(butteR)
# library(gsubfn)
# library(stringi)
# library(sf)
# library(snakecase)
# library(data.table)
# library(cleaner)
# library(illuminate)
# library(randomcoloR) # install.packages("randomcoloR") # Used for cleaning log
```


```{r Loading_data, echo=FALSE}
# Load the survey data

# load kobo tool 
if(population == "host"){
  survey_sheet <- read.csv("../01_DAP/tool/host/survey_sheet.csv")
  choice_sheet <- read.csv("../01_DAP/tool/host/choice_sheet.csv")

  survey_sheet$name <- gsub(x =  survey_sheet$name, pattern = "-", replacement = ".")
  
  # >>> This will need to be changed when we move from pilot to data collection:
  sample_location = read_xlsx(
    path = "C:/Users/Ben SMITH/Documents/Bangladesh/REACH Projects/MSNA 2021/JMSNA_Host_Sample_for_verification.xlsx", 
    sheet = "Pilot")
  
  # Coerce the data into the form desired:
  colnames(sample_location)[1] = c("respondent_id")
  sample_location$Age = as.numeric(sample_location$Age)
  sample_location$Union = tolower(sample_location$Union)
  sample_location$Union = gsub(pattern = " ", replacement = "_", x = sample_location$Union)
  sample_location$Ward = tolower(sample_location$Ward)
  sample_location$Ward = gsub(pattern = " ", replacement = "_", x = sample_location$Ward)
    
} else {
  
  survey_sheet <- read_xlsx(kobo_tool, sheet = 1)
  choice_sheet <- read_xlsx(kobo_tool, sheet = 2)

  survey_sheet$name <- gsub(x =  survey_sheet$name, pattern = "-", replacement = ".")
  
  FCNs = read_xlsx(path = "C:/Users/Ben SMITH/Documents/Bangladesh/REACH Projects/MSNA 2021/JMSNA_sample_for_verification_camps.xlsx", 
                   sheet = "Refugee_pilot")
  
  # Coerce the data into the form desired:
  colnames(FCNs) = c("respondent_id", "FCN", "Sample_camp_name")
  FCNs$respondent_id = as.numeric(FCNs$respondent_id) ; FCNs$FCN = as.numeric(FCNs$FCN)
  FCNs$Sample_camp_name = tolower(FCNs$Sample_camp_name)
  FCNs$Sample_camp_name = gsub(pattern = " ", replacement = "_", x = FCNs$Sample_camp_name)
}

# Convert the data from xlsx to csv's:
  # This is because it is read into R better as csv's, but we do not want to do this conversion manually.
  # This will overwrite the previous csv's.
  # There is a function in the utils.R script that may also do this (can't remember which of us wrote it).
  
  # hh
  data_sheet = read_xlsx(data_path, sheet = 1); write.csv(x = data_sheet, file = hh_path, row.names = FALSE)
  # indv
  data_sheet = read_xlsx(data_path, sheet = 2); write.csv(x = data_sheet, file = indv_path, row.names = FALSE)
  # indv_disability_repeat
  data_sheet = read_xlsx(data_path, sheet = 3); write.csv(x = data_sheet, file = indv_dis_repeat_path, row.names = FALSE)

# load datav from csv's:
hh <- read.csv(hh_path, stringsAsFactors = FALSE, na.strings=c("", " ", NA))
indv <- read.csv(indv_path, stringsAsFactors = FALSE, na.strings=c("", " ", NA))
indv_dis_repeat <- read.csv(indv_dis_repeat_path, stringsAsFactors = FALSE, na.strings=c("", " ", NA))

# Change some of the column names in the individual datasets: 
# 1. X_submission__uuid in indv
names(indv) <- gsub(x =  names(indv), pattern = "X_submission__uuid", replacement = "X_uuid")
names(indv) <- gsub(x =  names(indv), pattern = "_submission__uuid", replacement = "X_uuid") # Should be the above, but this covers whether the X is lost or not
# 2. X_submission__uuid in indv_dis_repeat
names(indv_dis_repeat) <- gsub(x = names(indv_dis_repeat), pattern = "X_submission__uuid", replacement = "X_uuid",)
names(indv_dis_repeat) <- gsub(x = names(indv_dis_repeat), pattern = "_submission__uuid", replacement = "X_uuid",)
# 3. ind_number_dis in indv_dis_repeat
names(indv_dis_repeat) <- gsub(x = names(indv_dis_repeat), pattern = "ind_number_dis", replacement = "ind_number")


# Create a variable to contain the X_uuid and the enumerator id:
# hh_enumerator_id <- hh %>% select(X_uuid, enumerator_id)

```

# `r print(paste0("Community: ", population))`
#### `r print(data_path)`

```{r Date_log, echo=FALSE}
## Create Date Log

# This section records the dates that the surveys were initially checked by this script. There will be a separate date_log_full file in the Data Analysis outputs folder for both the host and refugee datasets. This uses the hh datasets. It is only writen if 'output' == yes in the "daily_checks.R" script. This will output a date_log_full.csv file that contains all of the dates for each community as well as archiving .csv's that record each instance the date logs are written.   

# TODO Change the name of this column to monitored_date so that it is a little clearer.

# >>> REQUIRED ONLY ON THE FIRST DAY OF DATA COLLECTION
# date_log_full <- data.frame("X_uuid" = hh[,"X_uuid"], "reported_date" = day_to_run)
# write.csv(date_log_full, paste0(date_log_path,"date_log_full.csv"), row.names=FALSE)
# <<<

# Read in the previous date log:
date_log <- read.csv(paste0(date_log_path, "date_log_full.csv"), 
                     stringsAsFactors = FALSE, na.strings = c("", " ", NA))

# Store the monitoring period:
prev_monitor = max(date_log$reported_date)

# Convert the excel csv date format to ymd:
# If this has been fiddled with in Excel then the format may not be correct and you will get an error. 
# TODO Make more robust
date_log$reported_date <- ymd(date_log$reported_date) 

# Join the dates of surveys that have already been monitored to the input data:
hh <- hh %>% dplyr::left_join(date_log, by = "X_uuid")
# Fill any blank reported dates (i.e. new data entries) with today's date
if(length(is.na(hh$reported_date))>0){hh$reported_date <- if_else(is.na(hh$reported_date), day_to_run, hh$reported_date)}

# Update the date_log_full with the new data and their monitoring dates:
date_log_full <- hh %>% select(X_uuid, reported_date)

if(write_csv_output == "yes"){
 write.csv(date_log_full, paste0(date_log_path, gsub(x = day_to_run, pattern = "-", replacement = "_"), "_date_log_full.csv"), row.names=FALSE)
 write.csv(date_log_full, paste0(date_log_path,"Daily_Achive/date_log.csv"), row.names=FALSE)
}

```


```{r Todays_data, echo=FALSE}
### Create daily datasets

# These datasets contain all of the data that has not yet been monitored.

# Household:
  # Create a dataset containing today's data with consent:
  hh_consent_full  <- hh %>% filter(informed_consent =="yes")
  hh_consent_daily <- hh %>% filter(informed_consent =="yes" | reported_date == day_to_run)
  
  # TODO: Delete?
  # Create a dataset that contains all of the hh data with consent:
  # hh_consent_daily <- hh %>% filter(informed_consent =="yes") # to run full data
  # hh_day_data <- hh %>% filter(reported_date == day_to_run) 

# Individual
  # # Create a vector of the UIDs in today's consented data:
  #  <- hh_consent_daily$X_uuid  #to run daily data
  
  # Create a dataset that contains all of the individual data with consent:
  indv_daily_data <- indv %>% filter(X_uuid %in% hh_consent_daily$X_uuid)

# Individual Disability Repeat loop:
  # indv_dis_repeat_daily_data <- indv_dis_repeat %>% filter(ind_number %in% indv_daily_data$ind_number)
  indv_dis_repeat_daily_data <- indv_dis_repeat %>% filter(X_uuid %in% hh_consent_daily$X_uuid)
```

## General Checks

## 1. Daily Progress Tracking
Total number of household surveys taken so far for `r population` community is **`r nrow(hh)`**.

The monitoring period is `r paste0(prev_monitor, " to ", Sys.time())`. Any surveys completed after, but on the same day, that the previous data was downloaded will be included here.
```{r Progress_tracking, eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

if(population=="host"){
  survey_complete_by_reach <- hh %>%  group_by(reported_date, union_name)
} else {
  survey_complete_by_reach <- hh %>%  group_by(reported_date, camp_name)
}


# Create a dataset recording the number of surveys done so far per area and how many consented:
survey_complete_by_reach <- survey_complete_by_reach %>% summarise(
  "Total Surveys" = n(),
  "Surveys reached" = sum(reached == "yes", na.rm = T),
  "Surveys not reached" = sum(reached == "no", na.rm = T),
  "Surveys with 'no answer'" = sum(reached == "nobody_answering", na.rm = T),
# )
# 
# survey_complete_by_consent <- hh %>% group_by(reported_date, union_name)%>% summarise(
#   total_number_of_survey= n(),
  "Informed consent" = sum(informed_consent =="yes", na.rm = T),
  "Not consenting" = sum(informed_consent =="no", na.rm = T),
)


# TODO Delete?
# complete_by_enumerator_daily <- hh_consent_daily %>% group_by(enumerator_id) %>% summarise(daily_number_of_survey = n())  
# complete_by_enumerator <- left_join(x = overall_complete_by_enumerator, y = complete_by_enumerator_daily)

# Create nice tables showing the above outputs:
kable_styling(kable_input = kable(x = survey_complete_by_reach, longtable = T, booktabs = T, linesep = "", align = "c", 
                                  caption= "Total number of surveys reached and consenting per area (camp/union)."),
              position = "center")

# survey_complete_by_consent %>% kable(longtable = T, booktabs = T, linesep = "", align = "c",
#                                      caption= "Total number of surveys per camp/union by response option for “informed_consent”") %>% kable_styling(position = "center")

# complete_by_enumerator %>% kable(longtable = T, booktabs = T, linesep = "", align = "c",
#                                  caption= "Total number of completed survey by enumerator") %>% kable_styling(position = "center")

### ERROR: `summarise()` regrouping output by 'reported_date' (override with `.groups` argument)
### Is assumed due to only 2 entries in test data.
```

---


## 2. Survey verification (Duplicate IDs) 

Check whether there are duplicated respondent IDs in the consenting data for this monitoring period:
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# TODO make this use all data, not just daily.
# Find duplicated IDs in ALL household data:
duplicate_id = hh$respondent_id[duplicated(hh$respondent_id)]

# Filter this to include only those in the monitoring period:
# duplicate_id = duplicate_id[duplicate_id %in% hh_consent_daily$respondent_id] : this is done below

# Create a dataset of the basic data for those surveys with duplicated IDs:
check_duplicate_respondent_id <- hh_consent_daily %>% 
  filter(respondent_id %in% duplicate_id) %>%
  select(c("reported_date","X_uuid","enumerator_id","respondent_id")) %>%
  arrange(respondent_id)

kable_styling(kable_input = kable(x = check_duplicate_respondent_id,
                                  longtable = T, booktabs = T, linesep = "", align = "c", 
                                  caption = "Surveys where respondent_id is not unique"),
              position = "center")

# Not sure what this does:...
# check_duplicate_respondent_id_pi_long <- check_duplicate_respondent_id %>% 
#   pivot_longer(-c("reported_date","X_uuid","enumerator_id"), names_to = "questions", values_to = "old_value") %>% 
#   mutate( survey_loop = "HH") %>% 
#   group_by(X_uuid) %>% 
#   mutate(ref_col = paste0("Surveys where respondent_id is not unique",cur_group_id()))


# Assign a blank list to be the cleaning log:
# all_cleaning_log <- list()
# all_cleaning_log[["duplicate_respondent_id"]] <- check_duplicate_respondent_id


```


---


Flag if sample FCN not identical with respondent FCN (if given) [camps only]
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# TODO - check whether this manages cases where no FCN given
if(population=="refugee"){
  
  FCN_missmatch <- left_join(x = hh_consent_daily[,c("X_uuid", "enumerator_id", "reported_date", "respondent_id", "hh_fcn")],
                             y = FCNs) 
  
  FCN_missmatch <- FCN_missmatch[FCN_missmatch$hh_fcn != FCN_missmatch$FCN, ]
  
  FCN_missmatch$Sample_camp_name <- NULL
  
  colnames(FCN_missmatch) = c("X_uuid", "enumerator_id", "reported_date", "respondent_id", "Respondent FCN", "Sample FCN")
  
  
  kable_styling(kable_input = kable(x = FCN_missmatch, longtable = T, booktabs = T, linesep = "", align = "c", 
                                  caption= "Survey FCN does not match sample FCN"),
              position = "center")
}

```

---

Flag if sample Camp Name is not identical with respondent camp_name [camps only]
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# TODO - check whether this manages cases where no FCN given
if(population=="refugee"){
  
  camp_missmatch <- left_join(x = hh_consent_daily[,c("X_uuid", "enumerator_id", "reported_date", 
                                                     "respondent_id", "hh_fcn", "camp_name")],
                             y = FCNs)
  
  camp_missmatch <- camp_missmatch[camp_missmatch$camp_name != camp_missmatch$Sample_camp_name, ]
  
  colnames(camp_missmatch) = c("X_uuid", "enumerator_id", "reported_date", "respondent_id", "Respondent FCN", "Sample FCN", "Respondent camp", "Sample Camp")
  
  
  kable_styling(kable_input = kable(x = camp_missmatch, longtable = T, booktabs = T, linesep = "", align = "c", 
                                  caption= "Survey FCN does not match sample FCN"),
              position = "center")
}

```

---

Flag if sample union and ward do not match the sample data [host only]
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

if(population=="host"){
  
  admin_missmatch <- left_join(x = hh_consent_daily[,c("X_uuid", "enumerator_id", "reported_date", 
                                                     "respondent_id", "union_name", "ward_name")],
                             y = sample_location)
  
  admin_missmatch$Age <- age_missmatch$Source <- NULL # remove columns
  
  admin_missmatch <- admin_missmatch[(admin_missmatch$union_name != admin_missmatch$Union) |
                                       (admin_missmatch$ward_name != admin_missmatch$Ward), ]
  
  colnames(admin_missmatch) = c("X_uuid", "enumerator_id", "reported_date", "respondent_id", "union_name", "ward_name", "Union","Ward")
  
  
  kable_styling(kable_input = kable(x = admin_missmatch, longtable = T, booktabs = T, linesep = "", align = "c", 
                                  caption= "Survey union_name or ward_name does not match sample Union or Ward"),
              position = "center")
}

```

---

Flag if sample Age/gender is not identical to Head of Household age/gender [host only]
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

if(population=="host"){
  
  age_missmatch <- left_join(x = hh_consent_daily[,c("X_uuid", "enumerator_id", "reported_date", "respondent_id", "respondent_age", "resp_gender")],
                             y = sample_location)
  
  age_missmatch$Ward  <- age_missmatch$Union  <- age_missmatch$Source <- NULL # remove columns
  
  age_missmatch <- age_missmatch[(age_missmatch$respondent_age != age_missmatch$Age) |
                                       (age_missmatch$resp_gender != age_missmatch$Gender), ]
  
  # colnames(age_missmatch) = c("X_uuid", "enumerator_id", "reported_date", "respondent_id", )
  
    
  kable_styling(kable_input = kable(x = age_missmatch, longtable = T, booktabs = T, linesep = "", align = "c", 
                                  caption= "Survey respondent_age or resp_gender does not match sample Union or Ward"),
              position = "center")
}

```

## 3. Enumerator and survey duration issues 

Durations:
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# The Load_Audit function relies on there only being the relevant audit files in the other/audit folder. Therefore empty that folder ready for use:
# unlink(x = path_unzip, recursive = TRUE) # Commented as this should have been done following the previous use of the audit function.

# Load in the audit data:
audit_yes <- Load_Audit(data = hh,
                        filter.column = "informed_consent",
                        path.to.zip = audit_zipfile,
                        path.to.unzip = path_unzip,
                        copy.zip = TRUE,
                        path.to.copy.zip = copy_zip_to,
                        delete.unzipped=TRUE)
# unzip(path.to.zip, exdir = path.to.unzip)
# all_uuid_df <- data.frame(all_uuids = basename(dirname(list.files(path_unzip, recursive=TRUE))),
#                           all_paths = dirname(list.files(path_unzip, recursive=TRUE, full.names = TRUE)))

dfl<-list()
for (i in 1:length(audit_yes)){
  d <- audit_yes[[i]]

  d$node <- gsub("\\[1]", "", d$node) # does this do anything?...
  
  # Start the time checking after the informed consent question:
  start_question <- d %>% filter(node == paste0(audit_node,"informed_consent") & !is.na(event)) %>% select(end)
  start_question <- min(start_question$end)
  
  # Find the end question, after which times will not be checked:
  end_question <- d %>% filter(node==paste0(audit_node,"end_note") & !is.na(node)) %>% select(end)
  end_question<-max(end_question$end)
  
  # Find the duration of the survey:
  duration_ms <- end_question-start_question
    # convert to seconds:
    # duration_secs <- duration_ms/1000
    duration_minutes<- round(duration_ms/(1000*60), 1)
    
    # Assign the duration to a dataframe:
    dfl[[i]] <- data.frame(uuid = names(audit_yes)[i],
                           # duration_ms = duration_ms,
                           # durations_secs = duration_secs,
                           duration_minutes = duration_minutes)
}

```

---

a) Surveys completed in less than 25 minutes
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# Join the survey duration to the survey details (id etc.):
duration_df2 <- do.call("rbind", dfl)
survey_time <- duration_df2 %>% filter(duration_minutes <25)

survey_time <- survey_time %>% left_join(hh_consent_full %>% select(reported_date, X_uuid, enumerator_id ), by = c("uuid"="X_uuid"))
survey_time <- survey_time %>% select(reported_date, uuid, enumerator_id, duration_minutes)

duration_df2 <- duration_df2 %>% mutate(
  duration_minutes = if_else(condition = is.infinite(duration_minutes), true = NA_real_, false = duration_minutes))

# Stats on the survey times:
mean_survey_time   <- mean(duration_df2$duration_minutes, na.rm = T)
median_survey_time <- median(duration_df2$duration_minutes, na.rm = T)

paste0("Mean Survey Time- ", mean_survey_time,"<p>")
paste0("Median Survey Time- ",median_survey_time,"<p>")

kable_styling(kable(x = survey_time, longtable = T, booktabs = T, linesep = "", align = "c", 
                    caption= "surveys which are completed in less than 25 min"),
              position = "center")

# Calcualte the survey times of the surveys in the monitoring period only:
survey_time <- survey_time %>% filter(reported_date == day_to_run)
survey_time <- survey_time %>% rename("X_uuid"="uuid")

# # Add the durations to the cleaning log:
# survey_time_pi_long <- survey_time %>% pivot_longer(-c("reported_date","X_uuid","enumerator_id"),
#                                                     names_to = "questions",values_to = "old_value") %>%
#   mutate(survey_loop = "HH") %>%
#   group_by(X_uuid) %>% 
#   mutate(ref_col = paste0("duration_less_than_25_min",cur_group_id()))
# 
# all_cleaning_log[["duration_cl"]] <- survey_time_pi_long
```

---

a.ii - Survey longer than 1hr
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# Join the survey duration to the survey details (id etc.):
duration_df2_ii <- do.call("rbind", dfl)
survey_time <- duration_df2_ii %>% filter(duration_minutes >60)

survey_time <- survey_time %>% left_join(hh_consent_full %>% select(reported_date, X_uuid, enumerator_id ), by = c("uuid"="X_uuid"))
survey_time <- survey_time %>% select(reported_date, uuid, enumerator_id, duration_minutes)

duration_df2_ii <- duration_df2_ii %>% mutate(
  duration_minutes = if_else(condition = is.infinite(duration_minutes), true = NA_real_, false = duration_minutes))

# Stats on the survey times:
mean_survey_time   <- mean(duration_df2_ii$duration_minutes, na.rm = T)
median_survey_time <- median(duration_df2_ii$duration_minutes, na.rm = T)

paste0("Mean Survey Time- ", mean_survey_time,"<p>")
paste0("Median Survey Time- ",median_survey_time,"<p>")

kable_styling(kable(x = survey_time, longtable = T, booktabs = T, linesep = "", align = "c", 
                    caption= "surveys which are completed in less than 25 min"),
              position = "center")

# Calcualte the survey times of the surveys in the monitoring period only:
survey_time <- survey_time %>% filter(reported_date == day_to_run)
survey_time <- survey_time %>% rename("X_uuid"="uuid")

# # Add the durations to the cleaning log:
# survey_time_pi_long <- survey_time %>% pivot_longer(-c("reported_date","X_uuid","enumerator_id"),
#                                                     names_to = "questions",values_to = "old_value") %>%
#   mutate(survey_loop = "HH") %>%
#   group_by(X_uuid) %>% 
#   mutate(ref_col = paste0("duration_less_than_25_min",cur_group_id()))
# 
# all_cleaning_log[["duration_cl"]] <- survey_time_pi_long
```

---

b) Duration statistics by enumerator – average time per survey per enumerator
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# List the mean and median survey durations for each enumerator: 
duration_df3 <- duration_df2 %>% left_join(hh_consent_full %>% select(reported_date, X_uuid, enumerator_id ), by = c("uuid"="X_uuid"))

duration_df3 <- duration_df3 %>% group_by(enumerator_id) %>% 
  summarise(mean_duration = mean(duration_minutes, na.rm = TRUE),
            median_duration = median(duration_minutes, na.rm=TRUE))

duration_df3 %>% kable(longtable = T, booktabs = T, linesep = "", align = "c",caption= "Duration Statistics of enumerators") %>% kable_styling(position = "center")
```

---

c) Duration by group
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# Find the group names: 
group_list = c()
for(l in 1:length(audit_yes)){
  group = strsplit(x = audit_yes[[l]]$node, split = "/")

  # Extract from list:
  group = sapply(group,"[",4)
  
  # Record node names:
  group_list = c(group_list, group)
}

# Reduce list to only unique group names:
nodes_unique = unique(group_list) ; nodes_unique = nodes_unique[!is.na(nodes_unique)]

# Set up a matrix to hold the time information:
times = matrix(data = NA, nrow = length(names(audit_yes)), ncol = length(nodes_unique))
rownames(times) = names(audit_yes) ; colnames(times) = nodes_unique

for(l in 1:length(audit_yes)){
  for(n in colnames(times)){
    au = audit_yes[[l]]
    x  = grep(pattern = n, x = au$node)
    if(length(x)==0){next} # Skip if group not answered
    t1 = min(au$start[x], na.rm = TRUE)
    t2 = max(au$end[x], na.rm = TRUE)
    times[l,n] = round((t2-t1)/ (1000*60),1)
  }
}

time_stats = data.frame(
  # "Group" = colnames(times),
  "Mean time" = colMeans(times, na.rm = TRUE),
  "Standard Deviation" = apply(times,2,sd, na.rm =TRUE))

kable_styling(kable_input = kable(x = time_stats, longtable = T, booktabs = T, linesep = "", align = "c", 
                                  caption= "Time taken in minutes for each group of questions"),
              position = "center")

```

---

d)  Number of surveys completed per enumerator per day:
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# Count the number of surveys done by each enumerator
overall_complete_by_enumerator <- data.frame(
  # Overall:
  a = hh_consent_full  %>% group_by(enumerator_id) %>% 
    summarise("Overall number of surveys completed (with consent)" = n()),
  # In monitoring period
  b = (hh_consent_daily %>% group_by(enumerator_id) %>% 
    summarise("Survey's completed in monitoring period (with consent)" = n()))[2])

colnames(overall_complete_by_enumerator) = c("enumerator_id", "Overall", "During monitoring period")

# Print table
kable_styling(kable_input = kable(x = overall_complete_by_enumerator, longtable = T, booktabs = T, linesep = "", align = "c", 
                                  caption= "Number of surveys completed per enumerator per day:"),
              position = "center")
```

---

e)	Check if enumerators selected dont_know for more than 15 questions
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# TODO Ben does not know why Sajnin has so much code and not just a row count... consider later

# Find all of the answers that include don't know in the tool answer sheet.
kobo_dont_know_choices  <- choice_sheet %>% filter(name == "dont_know")
  # Below was from ST, BS thinks that this finds all answers (e.g. "dont_know_where") and that it shouldn't. Ben's version above.
  # kobo_dont_know_choices  <- choice_sheet %>% filter(grepl(pattern = "dont_know", x = name))

# Find all of the select one question types: 
kobo_survey_select_one <- survey_sheet %>% filter(grepl(pattern = "select_one", x = type)) 

# Remove the "select_one" from the type names: 
kobo_survey_select_one$type <- gsub(x = kobo_survey_select_one$type, pattern = "select_one", replacement = "") %>% trimws()

# Subset the choice sheet to show only the questions/answers that are select_one and dont_know: 
all_select_one_dont_know <- kobo_survey_select_one %>% filter(type %in% kobo_dont_know_choices$list_name) 
all_select_one_dont_know <- all_select_one_dont_know$name

# Find the columns in the three dataset that qualify for the check:
hh_select_one_dont_know_cols <- all_select_one_dont_know[all_select_one_dont_know %in% names(hh)]
indv_select_one_dont_know_cols <- all_select_one_dont_know[all_select_one_dont_know %in% names(indv)]
indv_dis_repeat_select_one_dont_know_cols <- all_select_one_dont_know[all_select_one_dont_know %in% names(indv_dis_repeat)]

hh_dont_know_mltiple_cols_name <- hh %>% select(contains(".dont_know")) %>% names()
indv_dont_know_mltiple_cols_name <- indv %>% select(contains(".dont_know")) %>% names()
indv_dis_repeat_dont_know_mltiple_cols_name <- indv_dis_repeat %>% select(contains(".dont_know")) %>% names()

# Create a dataset with a column that shows whether there are >15 don't knows for the three datasets:
# More code than needed here, I don't think we need mutate.
hh_pattern_dont_know <- hh_consent_daily %>% mutate(
  "hh_dont_know_rowsum" = 
    rowSums(hh_consent_daily[hh_select_one_dont_know_cols] == "dont_know", na.rm = T) +
    rowSums(hh_consent_daily[hh_dont_know_mltiple_cols_name], na.rm = T)) %>%
  select("X_uuid", "enumerator_id", "hh_dont_know_rowsum")

indv_pattern_dont_know <- indv_daily_data %>% mutate(
  "dont_know_rowsum" = 
    rowSums(indv_daily_data[indv_select_one_dont_know_cols] == "dont_know", na.rm = T) +
    rowSums(indv_daily_data[indv_dont_know_mltiple_cols_name], na.rm = T)) %>%
  dplyr::group_by(X_uuid) %>% 
  dplyr::summarise(indv_dont_know_rowsum = sum(dont_know_rowsum, na.rm = T)) %>%
  select(X_uuid, indv_dont_know_rowsum)

indv_dis_repeat_pattern_dont_know <- indv_dis_repeat_daily_data %>% mutate(
  "dont_know_rowsum" = 
    rowSums(indv_dis_repeat_daily_data[indv_dis_repeat_select_one_dont_know_cols] == "dont_know",na.rm = T) +
    rowSums(indv_dis_repeat_daily_data[indv_dis_repeat_dont_know_mltiple_cols_name],na.rm = T))%>%
  dplyr::group_by(X_uuid) %>% 
  dplyr::summarise(indv_dis_repeat_dont_know_rowsum = sum(dont_know_rowsum,na.rm = T)) %>% 
  select(X_uuid, indv_dis_repeat_dont_know_rowsum)

indv_all_pattern_dont_know <- left_join(x = indv_pattern_dont_know, y = indv_dis_repeat_pattern_dont_know)

dont_know_pattern_all <- hh_pattern_dont_know %>% left_join(indv_all_pattern_dont_know) %>% 
  dplyr::mutate(
    "number_of_dont_know" = hh_dont_know_rowsum + indv_dont_know_rowsum + indv_dis_repeat_dont_know_rowsum) %>%
  select(X_uuid, enumerator_id, number_of_dont_know, everything())

dont_know_more_than_15 <- dont_know_pattern_all %>% filter(number_of_dont_know >15)
colnames(dont_know_more_than_15) = c("X_uuid", "enumerator_id", "Total", "HH",
                                     "individual_info", "indv_disability_repeat")

kable_styling(kable(x = dont_know_more_than_15, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption= "Surveys where more than 15 dont_know answer selected"),
              position = "center")
# TODO - make the column names better so that they fit on a table.
# TODO - check that STs code works once there is more responses

```


## 4. Logical inconsistencies

Each row of the data cleaning SOP has a different code chunk below.

Clinics: flag if more than 3 selected – add column showing the selected options
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# -------------------------------------------------------------------------

```

---

Individuals_difficulties:
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# Flag if more than 33% of HH members selected – add column indicating number of HH members selected, hh_size, 
# and the values for indv_difficulty_seeing,indv_difficulty_hearing, indv_difficulty_walking, 
# indv_difficulty_remembering, indv_difficulty_selfcare, indv_difficulty_communicating for each selected individual

# Find the relevant column names:
difficulty_colnames <- indv_dis_repeat_daily_data %>% select(contains("difficulty")) %>% colnames()

individuals_difficulties <- indv_dis_repeat_daily_data %>% mutate(
  difficulty_col_rowsum = rowSums(indv_dis_repeat_daily_data[difficulty_colnames] == "lot_of_difficulty", na.rm =T) +
    rowSums(indv_dis_repeat_daily_data[difficulty_colnames] == "cannot_do", na.rm= T)) %>% 
  group_by(X_uuid) %>% 
  dplyr::summarise(indv_difficulty_rs = sum(difficulty_col_rowsum,na.rm = T),
                   Seeing = sum(indv_difficulty_seeing == "lot_of_difficulty" | indv_difficulty_seeing == "cannot_do", na.rm = T),
                   Hearing = sum(indv_difficulty_hearing == "lot_of_difficulty" | indv_difficulty_hearing == "cannot_do", na.rm = T),
                   Walking = sum(indv_difficulty_walking == "lot_of_difficulty" | indv_difficulty_walking == "cannot_do", na.rm = T),
                   Remembering = sum(indv_difficulty_remembering == "lot_of_difficulty" | indv_difficulty_remembering == "cannot_do", na.rm = T),
                   Selfcare = sum(indv_difficulty_selfcare == "lot_of_difficulty" | indv_difficulty_selfcare == "cannot_do", na.rm = T),
                   Communicating = sum(indv_difficulty_communicating== "lot_of_difficulty" | indv_difficulty_communicating == "cannot_do", na.rm = T)) %>%
  left_join(hh_consent_daily %>% select(reported_date,X_uuid,enumerator_id,hh_size)) %>% 
  mutate(
    "hh_size_fraction_raw" = hh_size/3,
    "hh_size_fraction" = round(hh_size_fraction_raw, digits=0),
    "difficulty_issue" = case_when(indv_difficulty_rs>hh_size_fraction~ "yes", T~ NA_character_)) %>% 
  filter(difficulty_issue=="yes") %>% 
  select(reported_date, X_uuid, enumerator_id, hh_size, indv_difficulty_rs, 
         Seeing, Hearing, Walking, Remembering, Selfcare, Communicating)

kable_styling(kable(x = individuals_difficulties, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption= "Individuals_difficulties"),
              position = "center")
```

---

shelter_issues_reason 1
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

```

---

shelter_issues_reason 2
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# -------------------------------------------------------------------------

shelter_issues_reason_inconsistency <- hh_consent_daily %>% mutate(
  shelter_issues_reason_inconsistency = case_when((shelter_issues_reason.damage_roof==1 & (leaks_during_rain!="yes"& lack_of_insulation!= "yes"))|
                                                    (shelter_issues_reason.damage_windows==1 & (leaks_during_rain!="yes"& lack_of_insulation!= "yes"))| 
                                                    (shelter_issues_reason.structure_unstable==1 & collapse_living_there!= "yes" )~ "yes",
                                                  T~ NA_character_)) %>% 
  filter(shelter_issues_reason_inconsistency=="yes") %>% 
  select(reported_date, X_uuid, enumerator_id, shelter_issues_reason, leaks_during_rain, lack_of_insulation, collapse_living_there)

kable_styling(kable(x = shelter_issues_reason_inconsistency, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "shelter_issues_reason 2"),
              position = "center")
```

---

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# -------------------------------------------------------------------------
# Improvement: flag if more than 5 selected – add column showing all selected options

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c",
#                     caption = "..."),
#               position = "center")
```

---

Improvement_reason 1: flag if did_not_receive_any_shelter_support & sold_materials selected – add column showing selected options
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# Improvement_reason

improvement_reason_inconsistency <- hh_consent_daily %>% mutate(
  improvement_reason_inconsistency = case_when(improvement_reason.did_not_receive_any_shelter_support==1 & improvement_reason.sold_materials==1 ~"yes",
                                               T~ NA_character_)) %>% 
  filter(improvement_reason_inconsistency=="yes") %>%
  select(reported_date, X_uuid, enumerator_id, improvement_reason, improvement_reason.did_not_receive_any_shelter_support, improvement_reason.sold_materials)

colnames(improvement_reason_inconsistency) = c("reported date", "X uuid", "enumerator id", "improvement reason", "did not receive any shelter support", "sold materials")

kable_styling(kable(x = improvement_reason_inconsistency, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "improvement_reason_inconsistency 1"),
              position = "center")
```

---

Improvement_reason
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# a
# ----

# Find the people with disabilities:
  # It appears that those without disabilities are listed, but do not have a 'calc_name' 
disabled <- indv_dis_repeat_daily_data[!is.na(indv_dis_repeat_daily_data$calc_name),]

males_18_59 = indv_daily_data %>% mutate(
  males_18_59 = case_when((ind_gender == "male" & individual_age %in% 18:59)~ "yes", TRUE~NA_character_)) %>%
  filter(males_18_59=="yes") %>%
  select(X_uuid, males_18_59)
  
# Find able males 18-59 by removing the disabled ones:
able_males = males_18_59[(!males_18_59$X_uuid %in% disabled$X_uuid),] 
# able_males = males_18_59 %>% select(!disabled$X_uuid %in% males_18_59$X_uuid) # has error if no content # or you could try this

# Join able males with hh data and filter this to show conflicts:
improvement_reason_inconsistency2 <- hh_consent_daily %>% left_join(able_males) %>% 
  filter(improvement_reason.no_able_bodied_person==1 & males_18_59== "yes") %>%
  select(reported_date, X_uuid, enumerator_id, improvement_reason.no_able_bodied_person, males_18_59) 
  # difficulty_colnames: You may have to summarise the difficulty_colnames before you can add.

kable_styling(kable(x = improvement_reason_inconsistency2, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "flag if no_able_bodied_person & at least one male person in the household aged 18-59"),
              position = "center")

# b
# ----
improvement_reason_inconsistency2b <- hh_consent_daily %>% mutate(
  "conflict" = case_when(improvement_reason.no_need_to_improve==1 & (leaks_during_rain!="no" | 
                                                                                 limited_ventilation !="no" |
                                                                                 dirt_debris !="no" |
                                                                                 lack_of_insulation !="no" |
                                                                                  collapse_living_there !="no")~ "yes", TRUE~"no")) %>%
  filter(conflict=="yes") %>%
  select(reported_date, X_uuid, enumerator_id, conflict, leaks_during_rain, 
         limited_ventilation, dirt_debris, lack_of_insulation, collapse_living_there)

colnames(improvement_reason_inconsistency2b) = c("reported date", "X uuid", "enumerator id", "conflict", "leaks during rain", 
                                                 "limited ventilation", "dirt debris", "lack of insulation", "collapse living there") 

kable_styling(kable(x = improvement_reason_inconsistency2b, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "Stated 'conflict' but has shelter problems:"),
              position = "center")

```

---

Shelter_materials_source
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c",
#                     caption = "..."),
#               position = "center")
```

---

Shelter_paid
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c",
#                     caption = "..."),
#               position = "center")
```

---

Group_nfi 
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

nfi_cols <- c("blankets", "mattresses_mats", "kitchen_sets", "torches_lights", "solar_lamps", "batteries", 
              "clothing", "winter_clothing", "shoes", "fans","mosquito_nets", "bedding_items")

group_nfi_inconsistency <- hh_consent_daily %>% mutate(
  nfi_insufficient = case_when(rowSums(hh_consent_daily[nfi_cols]!= "yes", na.rm = T) >8~"yes")) %>%
  filter(nfi_insufficient=="yes") %>% 
  select(reported_date, X_uuid, enumerator_id, nfi_cols)

colnames(group_nfi_inconsistency) <- c("reported_date", "X_uuid", "enumerator_id", "blankets", "mattresses mats", "kitchen sets", "torches lights",
                                       "solar lamps", "batteries", "clothing", "winter clothing", "shoes", "fans","mosquito nets", "bedding items")

kable_styling(kable(x = group_nfi_inconsistency, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "group_nfi_inconsistency"),
              position = "center")
```

---

alternative_cooking_fuel
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c",
#                     caption = "..."),
#               position = "center")

```

---

health_distance
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# TODO - this may need edits so that it uses all data, not daily.
health_distance_inconsistensy <- hh_consent_daily %>% mutate(
  health_distance_mean = mean(health_distance,na.rm = T),
  health_distance_sd = sd(health_distance, na.rm = T),
  min_allowable_health_distance = health_distance_mean - 2*health_distance_sd,
  max_allowable_health_distance = health_distance_mean + 2*health_distance_sd,
  health_distance_inconsistensy = case_when(health_distance>90 |
                                             health_distance> max_allowable_health_distance| 
                                             health_distance< min_allowable_health_distance ~ "yes",
                                           T~ NA_character_)) %>% 
  filter(health_distance_inconsistensy=="yes") %>% 
  select(reported_date, X_uuid, enumerator_id, contains("health_distance"), health_transportation)

colnames(health_distance_inconsistensy) = c("reported date", "X uuid", "enumerator id", "health distance", "health distance mean", 
                                            "health distance sd", "min allowable health distance", "max allowable health distance",
                                            "health distance inconsistensy", "health transportation")

kable_styling(kable(x = health_distance_inconsistensy, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "health_distance_inconsistensy"),
              position = "center")
```

---

health_barriers_not_accessed, health_barriers_accessed, health_barriers_no_need
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

health_service_inconsistency<- hh_consent_daily %>% mutate(
  health_service_inconsistency = case_when(((health_barriers_accessed.no_functional_facility_nearby==1 |
                                              health_barriers_accessed.health_services_are_too_far_away==1|
                                              health_barriers_not_accessed.no_functional_facility_nearby==1| 
                                              health_barriers_not_accessed.health_services_are_too_far_away==1|
                                              health_barriers_no_need.no_functional_facility_nearby==1 | 
                                              health_barriers_no_need.health_services_are_too_far_away==1) &
                                            health_distance<30)|((health_barriers_accessed.cannot_afford==1| 
                                                                    health_barriers_not_accessed.cannot_afford==1 |
                                                                    health_barriers_no_need.cannot_afford==1) &
                                                                   paid_healthcare=="yes") ~ "yes",
                                          T~ NA_character_)) %>% 
  filter(health_service_inconsistency=="yes") %>%
  select(reported_date, X_uuid, enumerator_id, health_barriers_accessed, health_barriers_not_accessed, 
         health_barriers_no_need, health_distance, health_transportation, paid_healthcare)

colnames(health_service_inconsistency) = c("reported date", "X uuid", "enumerator id", "health barriers accessed", "health barriers not accessed",
                                           "health barriers no need", "health distance", "health transportation", "paid healthcare")

kable_styling(kable(x = health_service_inconsistency, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "health_service_inconsistency"),
              position = "center")
```

---

group_enrolment & group_distance_learning [CAMPS ONLY]
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c",
#                     caption = "..."),
#               position = "center")
```

---

group_formal_enrolment, group_informal_enrolment & group_distance_learning [HOST ONLY]
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c",
#                     caption = "..."),
#               position = "center")
```

---

group_send_back [CAMPS ONLY]
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c",
#                     caption = "..."),
#               position = "center")
```

---

group_send_back [HOST ONLY]
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c",
#                     caption = "..."),
#               position = "center")
```

---

Set up some age range for the following check:
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

if(population == "refugee"){
  
  young_girls = c("girl_3_count", "girl_4_5_count") ; older_girls = c("girl_15_18_count", "girl_19_24_count")
  young_boys = c("boy_3_count", "boy_4_5_count") ; older_boys = c("boy_15_18_count", "boy_19_24_count")
  } else {
    young_girls = "girl_4_5_count" ; older_girls = "girl_15_18_count"
    young_boys = "boy_4_5_count" ; older_boys = "boy_15_18_count"
  }

```

---

distance_learning_barriers (girls)
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

LI_dist_learning_barriers_girls <- hh_consent_daily %>% mutate(
  LI_dist_learning_barriers_girls = case_when((
    (distance_learning_barriers_girls.working_outside_home == 1 & child_working_long_hours != "yes") |
      (distance_learning_barriers_girls.lack_content_older_children==1 & all_of(older_girls)==0) |
      (distance_learning_barriers_girls.lack_content_younger_children==1 & all_of(young_girls)==0) |
      (distance_learning_barriers_girls.lack_light==1 & (solar_lamps=="yes")) |
      (distance_learning_barriers_girls.marriage_pregnancy==1 & (girls_married== "yes" | child_marriage!="yes"))
    )~"yes", T~ NA_character_)) %>%
  filter(LI_dist_learning_barriers_girls=="yes") %>%
  select(reported_date, X_uuid, enumerator_id, distance_learning_barriers_girls, young_girls,
         older_girls, solar_lamps, girls_married, child_marriage)

kable_styling(kable(x = LI_dist_learning_barriers_girls, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "LI_dist_learning_barriers_girls"),
              position = "center")

```

---

distance_learning_barriers (boys)
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

LI_dist_learning_barriers_boys <- hh_consent_daily %>% mutate(
  LI_dist_learning_barriers_boys = case_when((
    (distance_learning_barriers_boys.working_outside_home == 1 & child_working_long_hours != "yes") |
      (distance_learning_barriers_boys.lack_content_older_children==1 & all_of(older_boys)==0) |
      (distance_learning_barriers_boys.lack_content_younger_children==1 & all_of(young_boys)==0) |
      (distance_learning_barriers_boys.lack_light==1 & (solar_lamps=="yes")) |
      (distance_learning_barriers_boys.marriage_pregnancy==1 & (boys_married== "yes" | child_marriage!="yes"))
    )~"yes", T~ NA_character_)) %>%
  filter(LI_dist_learning_barriers_boys=="yes") %>%
  select(reported_date, X_uuid, enumerator_id, distance_learning_barriers_boys, young_boys,
         older_boys, solar_lamps, boys_married, child_marriage)


kable_styling(kable(x = LI_dist_learning_barriers_boys, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "LI_dist_learning_barriers_boys"),
              position = "center")
```

---

send_back_barriers_girls
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

send_back_barriers_girls <- hh_consent_daily %>% mutate(
  send_back_barriers_girls = case_when((
    (distance_learning_barriers_girls.working_outside_home == 1 & child_working_long_hours != "yes") |
      (send_back_barriers_girls.lack_content_older_children==1 & all_of(older_girls)==0) |
      (send_back_barriers_girls.lack_content_younger_children==1 & all_of(young_girls)==0) |
      # (send_back_barriers_girls.lack_light==1 & (solar_lamps=="yes")) | # Lack of light does not exist.
      (send_back_barriers_girls.marriage_pregnancy==1 & (girls_married== "yes" | child_marriage!="yes"))
    )~"yes", T~ NA_character_)) %>%
  filter(send_back_barriers_girls=="yes") %>%
  select(reported_date, X_uuid, enumerator_id, distance_learning_barriers_girls, young_girls,
         older_girls, solar_lamps, girls_married, child_marriage)

kable_styling(kable(x = send_back_barriers_girls, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "send_back_barriers_girls"),
              position = "center")

```

---

send_back_barriers_boys
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

LI_send_back_barriers_boys <- hh_consent_daily %>% mutate(
  LI_send_back_barriers_boys = case_when((
    (send_back_barriers_boys.working_outside_home == 1 & child_working_long_hours != "yes") |
      (send_back_barriers_boys.lack_content_older_children==1 & all_of(older_boys)==0) |
      (send_back_barriers_boys.lack_content_younger_children==1 & all_of(young_boys)==0) |
      # (send_back_barriers_boys.lack_light==1 & (solar_lamps=="yes")) | # send_back_barriers_boys.lack_light does not exist
      (send_back_barriers_boys.marriage_pregnancy==1 & (boys_married== "yes" | child_marriage!="yes"))
    )~"yes", T~ NA_character_)) %>%
  filter(LI_send_back_barriers_boys=="yes") %>%
  select(reported_date, X_uuid, enumerator_id, distance_learning_barriers_boys, young_boys,
         older_boys, solar_lamps, boys_married, child_marriage)


kable_styling(kable(x = LI_send_back_barriers_boys, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "LI_send_back_barriers_boys"),
              position = "center")
```

---

send_back_challenges_girls
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

send_back_challenges_girls <- hh_consent_daily %>% mutate(
  send_back_challenges_girls = case_when((
    (send_back_challenges_girls.working_outside_home == 1 & child_working_long_hours != "yes") |
      (send_back_challenges_girls.lack_content_older_children==1 & all_of(older_girls)==0) |
      (send_back_challenges_girls.lack_content_younger_children==1 & all_of(young_girls)==0) |
      # (send_back_challenges_girls.lack_light==1 & (solar_lamps=="yes")) | # .lack_light does not exist
      (send_back_challenges_girls.marriage_pregnancy==1 & (girls_married== "yes" | child_marriage!="yes"))
    )~"yes", T~ NA_character_)) %>%
  filter(send_back_challenges_girls=="yes") %>%
  select(reported_date, X_uuid, enumerator_id, distance_learning_barriers_girls, young_girls,
         older_girls, solar_lamps, girls_married, child_marriage)

kable_styling(kable(x = send_back_challenges_girls, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "send_back_challenges_girls"),
              position = "center")

```

---

send_back_challenges_boys
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

send_back_challenges_boys <- hh_consent_daily %>% mutate(
  send_back_challenges_boys = case_when((
    (send_back_challenges_boys.working_outside_home == 1 & child_working_long_hours != "yes") |
      (send_back_challenges_boys.lack_content_older_children==1 & all_of(older_boys)==0) |
      (send_back_challenges_boys.lack_content_younger_children==1 & all_of(young_boys)==0) |
      # (send_back_challenges_boys.lack_light==1 & (solar_lamps=="yes")) | # .lack_light does not exist
      (send_back_challenges_boys.marriage_pregnancy==1 & (boys_married== "yes" | child_marriage!="yes"))
    )~"yes", T~ NA_character_)) %>%
  filter(send_back_challenges_boys=="yes") %>%
  select(reported_date, X_uuid, enumerator_id, distance_learning_barriers_boys, young_boys,
         older_boys, solar_lamps, boys_married, child_marriage)


kable_styling(kable(x = send_back_challenges_boys, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "send_back_challenges_boys"),
              position = "center")
```

---

send_back_barriers_girls, send_back_barriers_boys, send_back_challenges_girls, send_back_challenges_boys, return_barriers_girls, return_barriers_boys
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c",
#                     caption = "..."),
#               position = "center")
```

---

nutrition_barriers_not_accessed
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

nutrition_barriers_not_accessed_cols<- c("nutrition_barriers_not_accessed.already_referred", "nutrition_barriers_not_accessed.not_admitted",
                                         "nutrition_barriers_not_accessed.waiting_times", "nutrition_barriers_not_accessed.language_barriers")

nutrition_barriers_not_accessed_inconsistency <- hh_consent_daily %>% mutate(
  nutrition_barriers_not_accessed_inconsistency = case_when(child_taken_no_support_HH_count>0 &
                                                              rowSums(hh_consent_daily[nutrition_barriers_not_accessed_cols]==0,na.rm = T)
                                                            ~"yes", T~NA_character_)) %>% 
  filter(nutrition_barriers_not_accessed_inconsistency=="yes") %>% 
  select(reported_date, X_uuid, enumerator_id, nutrition_barriers_not_accessed_cols, 
         child_taken_no_support_HH_count, child_not_taken_after_referral_HH_count)

colnames(nutrition_barriers_not_accessed_inconsistency) = c("reported date", "X uuid", "enumerator id", "nutrition barriers not accessed: already referred", 
                                                            "nutrition barriers not accessed: not admitted", "nutrition barriers not accessed: waiting times",
                                                            "nutrition barriers not accessed: language barriers", "child taken no support HH count",
                                                            "child not taken after referral HH count")

kable_styling(kable(x = nutrition_barriers_not_accessed_inconsistency, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "nutrition_barriers_not_accessed_inconsistency"),
              position = "center")
```

---

Nutrition 2
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c",
#                     caption = "..."),
#               position = "center")
```

---

PLW admitted: not tested, but should work...
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
if(population=="refugee"){

  # case_when(hh_consent_daily$plw_admitted > hh_consent_daily$plw_sfs ~ "yes", TRUE~NA_character_)
  index = which(hh_consent_daily$plw_admitted > hh_consent_daily$plw_sfs)
  
  plw = hh_consent_daily[index, c("reported_date", "X_uuid", "enumerator_id", "plw_admitted", "plw_sfs")]
    
  kable_styling(kable(x = plw, longtable = T, booktabs = T, linesep = "", align = "c",
                      caption = "flag if plw_admitted > plw_sfs "), position = "center")
}

```

---

Folic Acid
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c",
#                     caption = "..."),
#               position = "center")
```

---

Food Barriers - not checked yet
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
if(population=="refugee"){
  
  food_barriers <- hh_consent_daily %>% mutate(
    food_barriers = case_when(((food_barriers.no_assistance == 1) |
                                 (food_barriers.feedback==1 & 
                                    feedback.did_not_know_where!=1 & 
                                    feedback.could_not_go_out!=1) |
                                 (food_barriers.lack_response==1 & 
                                    feedback.did_but_it_was_not_responded != 1 & 
                                    feedback.did_but_the_response_was_not_satisfactory != 1))~"yes", T~NA_character_)) %>%
      filter(food_barriers=="yes") %>% 
      select(reported_date, X_uuid, enumerator_id, food_barriers, feedback)
  
kable_styling(kable(x = food_barriers, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "food_barriers"),
              position = "center")
}
```

---

group_livelihood_coping
*Cara* - (child_marriage == "yes" & (gir7ls_married == 0 & boys_married == 0)
This was "child_marriage AND (girls_married == 0 AND boys_married == 0)" in the instructions but I have edited the start. Is this correct that "child_marriage" equals yes to qualify?
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# Set income columns of interest for 2nd check: [this is no longer desired].
# main_income = c("main_income_source.salaried_work", "main_income_source.casual_labor",
#                 "main_income_source.business", "main_income_source.cash_for_work",
#                 "main_income_source.donations")
# if(population=="host"){main_income = c(main_income, "main_income_source.government_benefits")}


# Find individual ages as TRUE/FALSE:
age = colnames(hh_consent_daily)[grep(pattern = "ind_age", colnames(hh_consent_daily))]
age = hh_consent_daily[,age]
adult = t(case_when(age>=18~TRUE, age<18~FALSE))
child = t(case_when(age>=18~FALSE, age<18~TRUE))

# Find whether individuals work as TRUE/FALSE:
income = colnames(hh_consent_daily)[grep(pattern = "individuals_income.individual", colnames(hh_consent_daily))]
income = hh_consent_daily[,income]
income = t(case_when(income==1~TRUE, income==0~FALSE))
# rownames(income) = hh_consent_daily$X_uuid

# Find which individuals can work but are over 18 then summerise this to a single vector:
child_income = child * income ; child_income = rowSums(child_income, na.rm = TRUE)
adult_income = adult * income ; adult_income = rowSums(adult_income, na.rm = TRUE)

# imcome_age = data.frame("X_uuid" = rownames(imcome_age), "imcome_age" = rowSums(imcome_age, na.rm = TRUE), row.names = NULL)
# TODO - I think that this should work, but you should check it once you have more data.


# Do the checks:
group_livelihood_coping_inconsistency <- hh_consent_daily %>% mutate(
  group_livelihood_coping_inconsistency = case_when(
    begging=="yes" |
      # (hh_consent_daily$depending_on_food_rations== "yes" & any(hh_consent_daily$main_income==1)
       # (hh$income_source.salaried_work==1| hh$income_source.casual_labor==1|hh$income_source.business==1 | hh$income_source.government_benefits==1 |
       #     hh$income_source.cash_for_work==1 | hh$income_source.donations==1))| ((hh$selling_food_rations=="yes" | hh$selling_nfis=="yes") &
      ((selling_food_rations == "yes" | selling_nfis == "yes") & main_income_source.sale_assistance != 1) |
      (child_working_long_hours == "yes" & child_income ==0) |
      (child_marriage == "yes" & girls_married == 0 & boys_married == 0) |
      (risk_jobs == "yes" & rowSums(income, na.rm = TRUE)) |
      (adults_working_long_hours == "yes" & adult_income == 0)~"yes", TRUE~NA_character_)) %>%
  filter(group_livelihood_coping_inconsistency=="yes") %>%
  select(c("reported_date", "X_uuid", "enumerator_id", "group_livelihood_coping_inconsistency", "begging",
           "selling_food_rations", "selling_nfis", "main_income_source"))

colnames(group_livelihood_coping_inconsistency) = gsub(x = colnames(group_livelihood_coping_inconsistency), 
                                                       pattern = "_", replacement = " ")

kable_styling(kable(x = group_livelihood_coping_inconsistency, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "group_livelihood_coping_inconsistency"),
              position = "center")
```

---

group_livelihood_coping2
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c",
#                     caption = "..."),
#               position = "center")
```

---

coping_reason
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c",
#                     caption = "..."),
#               position = "center")

```

---

coping_reason 2
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# cooking_fuel for HC and alternative_cooking_fuel for R

# Set columns of interest for distance learning:
if(population=="host"){dist_learning_cols = c(
  "distance_learning_girls_4_5", "distance_learning_girls_6_14", "distance_learning_girls_15_18",
  "distance_learning_boys_4_5", "distance_learning_boys_6_14", "distance_learning_boys_15_18")
} else {dist_learning_cols = c(
  "distance_learning_girls_3", "distance_learning_girls_4_5", "distance_learning_girls_6_14",
  "distance_learning_girls_15_18", "distance_learning_girls_19_24", "distance_learning_boys_3",
  "distance_learning_boys_4_5", "distance_learning_boys_6_14",	"distance_learning_boys_15_18",
  "distance_learning_boys_19_24")
}

# Set the cooking flue column names:
if(population=="host"){cooking_fuel_cols = c(
  "cooking_fuel.buying_lpg_refills", "cooking_fuel.firewood_purchased")
} else{cooking_fuel_cols = c(
  "alternative_cooking_fuel.buying_lpg_refills", "alternative_cooking_fuel.firewood_purchased")
}

coping_reason_inconsistency_2 <- hh_consent_daily %>% mutate(
  coping_reason_inconsistency_2 = case_when(
    (coping_reason.food == 1 & food_expenditure==0)|
      (coping_reason.healthcare == 1 & (paid_healthcare !="yes"| health_expenditure==0))|
      (coping_reason.education ==1 & rowSums(hh_consent_daily[dist_learning_cols]==1, na.rm = T)) | # complicated, but I think it works...
      (coping_reason.education ==1 & education_expenditure==0)|
      ((coping_reason.clothing ==1 |coping_reason.hh_items==1) & freq_nfi_expenditure==0)|
      # rent - added below in if statement
      (coping_reason.shelter ==1 & (improvement.dont_know | improvement.no_improvement | improvement.other | shelter_expenditure == 0)) |
      (coping_reason.cooking_fuel ==1 & (cooking_fuel_cols[1] !=1 | cooking_fuel_cols[2] != 1)) | 
      (coping_reason.cooking_fuel ==1 & fuel_expenditure == 0) |
      (coping_reason.hygiene_items ==1 & freq_nfi_expenditure == 0) |
      # water added below in if statement...
      (coping_reason.water ==1 & water_expenditure == 0)
    ~"yes", TRUE~ NA_character_)) # This will return "yes" where it is TRUE and NA where it is not, but is present (I think)


# Add in the bits needed for if it refugee community:
if(population=="refugee"){x = case_when((
  
  # rent
  coping_reason_inconsistency_2$coping_reason.water ==1 & 
    (coping_reason_inconsistency_2$water_coping.spend_money !=1 &
       coping_reason_inconsistency_2$water_coping.buy_water !=1) |
  # water  
    (coping_reason_inconsistency_2$coping_reason.rent ==1 &
       (coping_reason_inconsistency_2$shelter_paid.no_need==1 |
          coping_reason_inconsistency_2$shelter_paid.dont_know==1 |
          coping_reason_inconsistency_2$shelter_paid.other==1)))~"yes", 
  TRUE~ "no")
  
} else {x = case_when(
  
  # water
  (coping_reason_inconsistency_2$coping_reason.water == 1 & 
     coping_reason_inconsistency_2$water_coping.spend_money !=1)~"yes", 
  TRUE~"no")

}

coping_reason_inconsistency_2$coping_reason_inconsistency_2[x=="yes"] = "yes"

# Specify the columns to include, this depends on the population:
cols = c("reported_date", "X_uuid", "enumerator_id", "coping_reason", "coping_reason_inconsistency_2", "food_expenditure", 
         "health_expenditure", "paid_healthcare", "education_expenditure", "infreq_nfi_expenditure",
         "rent_expenditure", "shelter_expenditure", "improvement", "fuel_expenditure",
         "freq_nfi_expenditure", "water_coping", "water_expenditure", dist_learning_cols, cooking_fuel_cols)
if(population=="refugee"){cols = c(cols, "shelter_paid")}

coping_reason_inconsistency_2 = coping_reason_inconsistency_2 %>% filter(coping_reason_inconsistency_2=="yes") %>% select(cols)

colnames(coping_reason_inconsistency_2) = gsub(pattern = "_", replacement = " ", x = colnames(coping_reason_inconsistency_2))
colnames(coping_reason_inconsistency_2) = gsub(pattern = ".", replacement = ": ", x = colnames(coping_reason_inconsistency_2), fixed = T)

# Create the table print out:
kable_styling(kable(x = coping_reason_inconsistency_2, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "coping_reason_inconsistency_2"),
              position = "center")

```

---

Income_source
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c",
#                     caption = "..."),
#               position = "center")
```

---

Amount Outliers
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# -------------------------------------------------------------------------
amounts = c("assistance_amount", "salaried_work_amount", "casual_labor_amount", "business_amount",
            "remittances_amount", "family_friends_amount", "cfw_amount", "donations_amount",
            "sale_assistance_amount", "other_amount")
if(population=="host"){amounts = c(amounts, "government_benefits_amount")}

# Sum the amounts:
hh_consent_full$total_amount = rowSums(x = hh_consent_full[,amounts], na.rm = TRUE)

# Set up a matrix to hold the stats:
amounts = matrix(ncol = length(amounts)+1,
                 nrow = 4, data = NA, 
                 dimnames = list(c("mean", "SD", "mean-2SD", "mean+2SD"), 
                                 c(amounts, "total_amount")))

# Extract all of the expenditure data: 
amounts_data <- hh_consent_full[,colnames(amounts)]

# Compute the stats:
for(e in colnames(amounts)){
  amounts[1,e] = mean(amounts_data[,e], na.rm = TRUE)
  amounts[2,e] = sd(x = amounts_data[,e], na.rm = TRUE)
  amounts[3,e] = amounts[1,e] - 2*amounts[2,e]
  amounts[4,e] = amounts[1,e] + 2*amounts[2,e]
} # The above makes NaN and NA values, though I do not think that will affect anything.

# Calculate the daily amount totals:
hh_consent_daily$total_amount <- rowSums(hh_consent_daily[, colnames(amounts)[1:(ncol(amounts)-1)]], na.rm = TRUE)

# Create a subset of the data to use for calculations
amounts_data_day <- hh_consent_daily[, c("reported_date", "X_uuid", "enumerator_id", colnames(amounts))]

# Find instances in tha daily data where values are outliers:
amounts_data_day <- amounts_data_day %>% mutate(
  "outlier" = case_when((
    (assistance_amount < amounts[3, "assistance_amount"] | assistance_amount > amounts[4, "assistance_amount"]) |
      (salaried_work_amount < amounts[3, "salaried_work_amount"] | salaried_work_amount > amounts[4, "salaried_work_amount"]) |
      (casual_labor_amount < amounts[3, "casual_labor_amount"] | casual_labor_amount > amounts[4, "casual_labor_amount"]) |
      (business_amount < amounts[3, "business_amount"] | business_amount > amounts[4, "business_amount"]) |
      (remittances_amount < amounts[3, "remittances_amount"] | remittances_amount > amounts[4, "remittances_amount"]) |
      (family_friends_amount < amounts[3, "family_friends_amount"] | family_friends_amount > amounts[4, "family_friends_amount"]) |
      (cfw_amount < amounts[3, "cfw_amount"] | cfw_amount > amounts[4, "cfw_amount"]) |
      (sale_assistance_amount < amounts[3, "sale_assistance_amount"] | sale_assistance_amount > amounts[4, "sale_assistance_amount"]) |
      (other_amount < amounts[3, "other_amount"] | other_amount > amounts[4, "other_amount"]) |
      (amounts_data_day[,(ncol(amounts_data_day)-1)] < amounts[3, (ncol(amounts)-1)] |
         amounts_data_day[,(ncol(amounts_data_day)-1)] > amounts[4, (ncol(amounts)-1)]) | 
      # ^^ This is for host only (government_benefits). 
      # If it exists as penultimate column, it will be checked, else other_amount will be harmlessly rechecked
      (total_amount < amounts[3, "total_amount"] | total_amount > amounts[4, "total_amount"]))~"yes", 
    TRUE~NA_character_)) %>%
  filter(outlier=="yes") %>%
  select(c("reported_date", "X_uuid", "enumerator_id", colnames(amounts)))
  # Sajnin has done this the opposite way around to you, where she subsets columns afterwards, but, doing it this way means that we can deal easily with government benefits.

colnames(amounts_data_day) = gsub(x = colnames(amounts_data_day), pattern = "_", replacement = " ")

kable_styling(kable(x = amounts_data_day, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "amounts_data_day"),
              position = "center")
```

---
Various Checks...
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# -------------------------------------------------------------------------
# food_expenditure 
# rent_expenditure 
  # TODO - not working
  # rent_expenditure_inconsistency <- hh_consent_daily %>% mutate(
  #   rent_expenditure_inconsistency = case_when((hh$rent_expenditure>0 & hh$shelter_type)~"yes", T~NA_character_))

# water_expenditure
# freq_nfi_expenditure
# fuel_expenditure
# transportation_expenditure 

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c",
#                     caption = "..."),
#               position = "center")
```

---

rent_expenditure
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

if(population=="refugee"){
  rent_expenditure = hh_consent_daily %>% mutate(
    rent_expenditure = case_when((
      (rent_expenditure > 0 & shelter_paid == "no_need") |
      (rent_expenditure == 0 & shelter_paid != "no_need"))~"yes", T~ NA_character_)) %>%
    filter(rent_expenditure=="yes") %>% 
    select(reported_date, X_uuid, enumerator_id, shelter_paid, rent_expenditure)
  
  kable_styling(kable(x = rent_expenditure, longtable = T, booktabs = T, linesep = "", align = "c",
                      caption = ""),
                position = "center")
}

```

---

fuel_expenditure
TODO - check whether this applies to camp and HC or just one or the other.
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

fuel_expenditure_inconsistency <- hh_consent_daily %>% mutate(
  fuel_expend_inconsistency= case_when((fuel_expenditure> 0 & (cooking_fuel_cols[1] != 1 & cooking_fuel_cols[2] !=1))|
                                         (fuel_expenditure== 0 & (cooking_fuel_cols[1] == 1 | cooking_fuel_cols[2] ==1))~ "yes",
                                       T~ NA_character_)) %>% 
  filter(fuel_expend_inconsistency=="yes") %>% 
  select(reported_date, X_uuid, enumerator_id, fuel_expenditure, cooking_fuel_cols)

colnames(fuel_expenditure_inconsistency) = gsub(pattern = "_", replacement = " ", x = colnames(fuel_expenditure_inconsistency))
colnames(fuel_expenditure_inconsistency) = gsub(pattern = ".", replacement = ": ", x = colnames(fuel_expenditure_inconsistency), fixed = T)

kable_styling(kable(x = fuel_expenditure_inconsistency, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "fuel_expenditure_inconsistency"),
              position = "center")
```

---

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# -------------------------------------------------------------------------
# shelter_expenditure
# infreq_nfi_expenditure
# health_expenditure
# education_expenditure
# debt_expenditure 

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c",
#                     caption = "..."),
#               position = "center")
```

---

Expenditure: Should flag unusually high/low values for each and the sum
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

expenditures = c("shelter_expenditure", "infreq_nfi_expenditure", "health_expenditure", "education_expenditure", "debt_expenditure")

# Sum the expenditures:
hh_consent_full$expenditure_total = rowSums(hh_consent_full[,expenditures], na.rm = TRUE)

# Set up a matrix to hold the stats:
expenditures = matrix(ncol = 6, nrow = 4, data = NA, 
                      dimnames = list(c("mean", "SD", "mean-2SD", "mean+2SD"), 
                                      c(expenditures, "expenditure_total")))


# Extract all of the expenditure data: 
expenditures_data <- hh_consent_full[,colnames(expenditures)]


# Compute the stats:
for(e in colnames(expenditures)){
  expenditures[1,e] = mean(expenditures_data[,e], na.rm = TRUE)
  expenditures[2,e] = sd(x = expenditures_data[,e], na.rm = TRUE)
  expenditures[3,e] = expenditures[1,e] - 2*expenditures[2,e]
  expenditures[4,e] = expenditures[1,e] + 2*expenditures[2,e]
}


# Run through the daily dataset and find instances where this values are outliers:
hh_consent_daily$expenditure_total <- rowSums(hh_consent_daily[, colnames(expenditures)[1:5]], na.rm = TRUE)
expenditures_data_day <- hh_consent_daily[, c("reported_date", "X_uuid", "enumerator_id", colnames(expenditures))]

expenditures_data_day <- expenditures_data_day %>% mutate(
  "outlier" = case_when((
    (shelter_expenditure < expenditures[3, "shelter_expenditure"] | shelter_expenditure > expenditures[4, "shelter_expenditure"]) |
      (infreq_nfi_expenditure < expenditures[3, "infreq_nfi_expenditure"] | infreq_nfi_expenditure > expenditures[4, "infreq_nfi_expenditure"]) |
      (health_expenditure < expenditures[3, "health_expenditure"] | health_expenditure > expenditures[4, "health_expenditure"]) |
      (education_expenditure < expenditures[3, "education_expenditure"] | education_expenditure > expenditures[4, "education_expenditure"]) |
      (debt_expenditure < expenditures[3, "debt_expenditure"] | debt_expenditure > expenditures[4, "debt_expenditure"]) |
      (expenditure_total < expenditures[3, "expenditure_total"] | expenditure_total > expenditures[4, "expenditure_total"]))~"yes", 
    TRUE~"no"))

expenditures_data_day = expenditures_data_day[expenditures_data_day$outlier=="yes",]

colnames(expenditures_data_day) = gsub(x = colnames(expenditures_data_day), pattern = "_", replacement = " ")

kable_styling(kable(x = expenditures_data_day, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "expenditures_data_day"),
              position = "center")

```

---

health_expenditure
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

health_expenditure_inconsistency<- hh_consent_daily %>% mutate(
  health_expenditure_inconsistency= case_when((health_expenditure>0 & paid_healthcare=="no")|
                                               (health_expenditure==0 & paid_healthcare=="yes")~"yes",
                                              T~NA_character_))%>% 
  filter(health_expenditure_inconsistency=="yes") %>% 
  select(reported_date, X_uuid, enumerator_id, paid_healthcare)

kable_styling(kable(x = health_expenditure_inconsistency, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "health_expenditure_inconsistency"),
              position = "center")
```

---

shelter_expenditure
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

shelter_expenditure_inconsistency <- hh_consent_daily %>% mutate(
  shelter_expenditure_inconsistency= case_when((shelter_expenditure>0 & shelter_materials_source.purchased==0)|
                                                 (shelter_expenditure==0 &shelter_materials_source.purchased==1)~"yes",
                                               T~ NA_character_))%>% 
  filter(shelter_expenditure_inconsistency=="yes") %>% 
  select(reported_date, X_uuid, enumerator_id, shelter_expenditure, shelter_materials_source)

kable_styling(kable(x = shelter_expenditure_inconsistency, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "shelter_expenditure_inconsistency"),
              position = "center")
```

---

sanitation_coping
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

sanitation_coping_inconsistency <- hh_consent_daily %>% mutate(
  sanitation_coping_inconsistency = case_when((sanitation_coping.no_issue==1 & sanitation_barriers_female.no_problem==0 & sanitation_barriers_male.no_problem==0 )|
                                               ((sanitation_coping.no_issue==0 & 
                                                   (sanitation_barriers_female.no_problem==1 |
                                                      sanitation_barriers_female.no_problem== NA) &
                                                   (sanitation_barriers_male.no_problem==1 |
                                                      sanitation_barriers_male.no_problem==NA)))~"yes", T~ NA_character_)) %>%
  select(reported_date,X_uuid,enumerator_id,sanitation_coping,sanitation_barriers_male,sanitation_barriers_female,sanitation_coping_inconsistency) %>% 
  filter(sanitation_coping_inconsistency=="yes")

kable_styling(kable(x = sanitation_coping_inconsistency, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "sanitation_coping_inconsistency"),
              position = "center")
```

---

group_water_quantity.
*Cara* - what is this showing? Is it as you expect?
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

group_water_quantity = hh_consent_daily %>% mutate(
  group_water_quantity = case_when((enough_water_bathing_facility == "not_applicable" & enough_water_bathing_shelter == "not_applicable")~"yes",
                                   T~ NA_character_)) %>%
  filter(group_water_quantity=="yes") %>% 
  select(reported_date, X_uuid, enumerator_id, sanitation_coping, enough_water_bathing_facility, enough_water_bathing_shelter)

colnames(group_water_quantity) <- c("reported date", "X uuid", "enumerator id", "sanitation coping",
                                    "enough water bathing facility",  "enough water bathing shelter") 

kable_styling(kable(x = group_water_quantity, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption = "Flag if 'enough_water_bathing_facility' AND 'enough_water_bathing_shelter' are 'not_applicable'."),
              position = "center")
```

---

child_needs
```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

# kable_styling(kable(x = ..., longtable = T, booktabs = T, linesep = "", align = "c",
#                     caption = "..."),
#               position = "center")
```

### Outliers check

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}
# TODO
# Cara wants the mean and SD at several points. This function will do this automatically.
# There is more code on this in the daily monitoring script in the rATA script.

# outliers_check_hh <- outlier_check(df = hh_consent_daily, kobo_tool_location = "../01_DAP/tool/host/Host_JMSNA_2021_v8.xlsx",
#                                    cols_to_report = c("X_uuid","enumerator_id"))# , include_multiple_choices = FALSE)
# 
# outliers_check_indv <- outlier_check(df = indv_daily_data,kobo_tool_location = "01_DAP/tool/host/Host_JMSNA_2021_v8.xlsx",
# cols_to_report = c("X_uuid"),include_multiple_choices = FALSE)


```


## 5. Other response

```{r eval=TRUE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

hh_other_cols <- hh %>% select(c(starts_with("other_"), ends_with("_other"))) %>% names()
ind_other_cols <- indv %>%  select(c(starts_with("other_"), ends_with("_other"))) %>% names()

hh_other <- hh_consent_daily %>%
  filter_at(vars(hh_other_cols), any_vars(!is.na(.))) %>%
  select(reported_date,X_uuid,enumerator_id,hh_other_cols)

#hh_other$other_freq_expenditure<- hh_other$other_freq_expenditure %>% as.character()
hh_other$other_amount<- hh_other$other_amount %>% as.character()
hh_other$water_coping.less_preferred_other<- hh_other$water_coping.less_preferred_other %>% as.character()
hh_other$water_coping.less_use_other<- hh_other$water_coping.less_preferred_other %>% as.character()


hh_other_pi_long <- hh_other %>% pivot_longer(-c("reported_date","X_uuid","enumerator_id"), names_to = "questions", values_to = "old_value") %>%
  mutate(survey_loop = "HH") %>% 
  group_by(X_uuid) %>% 
  mutate(ref_col = paste0("Other_response_",cur_group_rows()))

hh_other_pi_long <- hh_other_pi_long %>% filter(!is.na(old_value))

indv_other<-indv_daily_data %>% 
    filter_at(vars(ind_other_cols), any_vars(!is.na(.))) %>% 
    select(X_uuid,repeat_instance_name,ind_other_cols) %>% left_join(hh_consent_daily %>% select(reported_date,X_uuid,enumerator_id)) %>% 
    select(reported_date,X_uuid,repeat_instance_name,enumerator_id,ind_other_cols)


ind_other_pi_long <- indv_other %>% pivot_longer(-c("reported_date","X_uuid","repeat_instance_name","enumerator_id"),names_to = "questions",values_to = "old_value") %>% 
  mutate(
  survey_loop = "inividual") %>% 
  group_by(repeat_instance_name) %>% 
  mutate(ref_col = paste0("Other_response_", cur_group_rows()))

ind_other_pi_long <- ind_other_pi_long %>% filter(!is.na(old_value))

ind_other_pi_long$old_value <- ind_other_pi_long$old_value %>% as.character()


# cleaning_log_other <- bind_rows(hh_other_pi_long, ind_other_pi_long) %>% select(reported_date, X_uuid, survey_loop, repeat_instance_name, everything())
# 
# all_cleaning_log[["other_respose_cl"]] <- cleaning_log_other
# 
# kable_styling(kable(x = cleaning_log_other, longtable = T, booktabs = T, linesep = "", align = "c",
#                     caption = "'Other' answers"),
#               position = "center")
```

---

3.f.	Number of issues flagged by enumerator:
```{r eval=FALSE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE}

enumerator_list = c(
  check_duplicate_respondent_id$enumerator_id,
  FCN_missmatch$enumerator_id,
  camp_missmatch$enumerator_id,
  survey_time$enumerator_id,
  duration_df3$enumerator_id,
  dont_know_more_than_15$enumerator_id,
  individuals_difficulties$enumerator_id,
  shelter_issues_reason_inconsistency$enumerator_id,
  improvement_reason_inconsistency$`enumerator id`,
  improvement_reason_inconsistency2$enumerator_id,
  improvement_reason_inconsistency2b$enumerator_id,
  group_nfi_inconsistency$reported_date,
  health_distance_inconsistensy$`enumerator id`,
  health_service_inconsistency$`enumerator id`,
  LI_dist_learning_barriers_girls$enumerator_id,
  LI_dist_learning_barriers_boys$enumerator_id,
  send_back_barriers_girls$enumerator_id,
  LI_send_back_barriers_boys$enumerator_id,
  send_back_challenges_girls$enumerator_id,
  send_back_challenges_boys$enumerator_id,
  nutrition_barriers_not_accessed_inconsistency$`enumerator id`,
  plw$enumerator_id,
  food_barriers$enumerator_id,
  group_livelihood_coping_inconsistency$`enumerator id`,
  coping_reason_inconsistency_2$`enumerator id`,
  amounts_data_day$`enumerator id`,
  rent_expenditure$enumerator_id,
  fuel_expenditure_inconsistency$`enumerator id`,
  expenditures_data_day$`enumerator id`,
  health_expenditure_inconsistency$enumerator_id,
  shelter_expenditure_inconsistency$enumerator_id,
  sanitation_coping_inconsistency$enumerator_id,
  group_water_quantity$`enumerator id`
  )
if(population=="host"){enumerator_list = c(enumerator_list,admin_missmatch$enumerator_id, age_missmatch$enumerator_id}
# if(population=="host"){enumerator_list = c(enumerator_list,admin_missmatch$enumerator_id, age_missmatch$enumerator_id} # do the same for camps

# count(enumerator_list)
count = table(enumerator_list)
count = count[order(count, decreasing = TRUE)]
# freq = freq[,order(freq)]

kable_styling(kable(x = count, longtable = T, booktabs = T, linesep = "", align = "c",
                    caption= "Number of issues flagged per enumerator:"),
              position = "center")

```


```{r eval=FALSE, echo=FALSE, results='asis', warning=FALSE, messages=FALSE, include= FALSE}
## cleaning log
# cleaning log will be provided in separate excel file. This is currently not being written as deemed unneccesary for now.
all_cleaning_log$duration_cl$old_value <- all_cleaning_log$duration_cl$old_value %>% as.character()
final_cleaning_log <- do.call("bind_rows",all_cleaning_log)

final_cleaning_log <- final_cleaning_log %>% mutate(new_value =NULL,change_type=NULL) %>%
  select(reported_date, X_uuid, enumerator_id, survey_loop, questions, old_value, everything())

final_cleaning_log <- final_cleaning_log %>% rename("issues"="ref_col")

final_cleaning_log$reported_date <- final_cleaning_log$reported_date %>% lubridate::as_date()

final_cleaning_log <- final_cleaning_log %>% filter(reported_date == day_to_run)  #### Output daily cleaning log only



# work_book ---------------------------------------------------------------

final_cleaning_log_for_excel <- final_cleaning_log %>% mutate(
  unique_col = paste0(X_uuid,"_",issues)
)


headerStyle <- createStyle(fontSize = 12, 
                           fontColour = "#FFFFFF",
                           halign = "center",
                           valign = "center",
                           fontName = "Arial Narrow",
                           textDecoration = "bold",
                           fgFill = "#ee5859",
                           border = "TopBottomLeftRight ",
                           borderColour = "#fafafa",
                           wrapText = T,numFmt = "DATE"
)
bodyStyle <- createStyle(fontSize = 11, 
                         fontName = "Arial Narrow",
                         border = "TopBottomLeftRight ",
                         borderColour = "#4F81BD",
                         valign = "center",
                         halign = "left",
)


wb <- createWorkbook()
addWorksheet(wb,"cleaning log")
writeData(wb, sheet = 1, final_cleaning_log_for_excel, rowNames = F)

u = unique(final_cleaning_log_for_excel$unique_col)

for(x in u){
  y = which(final_cleaning_log_for_excel$unique_col == 3)
  
  mergeCells(wb, sheet = 1, cols = 1, rows = y+1 )
  mergeCells(wb, sheet = 1, cols = 2, rows = y+1)
  mergeCells(wb, sheet = 1, cols = 3, rows = y+1)
  mergeCells(wb, sheet = 1, cols = 4, rows = y+1)
  mergeCells(wb, sheet = 1, cols = 5, rows = y+1)
  mergeCells(wb, sheet = 1, cols = 6, rows = y+1)
  mergeCells(wb, sheet = 1, cols = 7, rows = y+1)
  mergeCells(wb, sheet = 1, cols = 10, rows = y+1)
  
}

addFilter(wb,sheet =  1, row = 1, cols = 1:ncol(final_cleaning_log_for_excel))
freezePane(wb, sheet = 1, firstCol = TRUE, firstRow = T)


addStyle(wb, sheet = 1, headerStyle, rows = 1, cols = 1:ncol(final_cleaning_log_for_excel), gridExpand = TRUE)
addStyle(wb, sheet = 1, bodyStyle, rows = 1:nrow(final_cleaning_log_for_excel)+1, cols = 1:ncol(final_cleaning_log_for_excel), gridExpand = TRUE)

setColWidths(wb, 1, cols = 1:ncol(final_cleaning_log_for_excel), widths = 25) 

##### color #####

for(x in u){
y = which(final_cleaning_log_for_excel$unique_col == x)

random.color <- randomColor(1, luminosity = "light") 

sty_date <- createStyle(numFmt = "dd/mm/yyyy",
                             fgFill=random.color,
                             fontSize = 11, 
                             fontName = "Arial Narrow",
                             border = "TopBottomLeftRight ",
                             borderColour = "#4F81BD",
                             valign = "center",
                             halign = "left")

style <- createStyle(fgFill=random.color,
                     fontSize = 11, 
                     fontName = "Arial Narrow",
                     border = "TopBottomLeftRight ",
                     borderColour = "#4F81BD",
                     valign = "center",
                     halign = "left",)
addStyle(wb, 1, style = sty_date, rows = y+1, cols = 1:1, gridExpand = T)
addStyle(wb, sheet = 1, style, rows = y+1, cols = 2:ncol(final_cleaning_log_for_excel), gridExpand = TRUE)

}

setColWidths(wb, 1, cols = which(names(final_cleaning_log_for_excel)== "unique_col"),hidden = T) 
##############################################


saveWorkbook(wb, file = paste0(cleaning_log_path, gsub(x = day_to_run, pattern = "-", replacement = ""), "_", "cleaning_log_", population, ".xlsx"), overwrite = TRUE)


```


